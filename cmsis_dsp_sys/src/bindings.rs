/* automatically generated by rust-bindgen 0.55.1 */

pub mod arm_status {
    #[doc = " @brief Error status returned by some functions in the library."]
    pub type Type = crate::ctypes::c_int;
    #[doc = "< No error"]
    pub const ARM_MATH_SUCCESS: Type = 0;
    #[doc = "< One or more arguments are incorrect"]
    pub const ARM_MATH_ARGUMENT_ERROR: Type = -1;
    #[doc = "< Length of data buffer is incorrect"]
    pub const ARM_MATH_LENGTH_ERROR: Type = -2;
    #[doc = "< Size of matrices is not compatible with the operation"]
    pub const ARM_MATH_SIZE_MISMATCH: Type = -3;
    #[doc = "< Not-a-number (NaN) or infinity is generated"]
    pub const ARM_MATH_NANINF: Type = -4;
    #[doc = "< Input matrix is singular and cannot be inverted"]
    pub const ARM_MATH_SINGULAR: Type = -5;
    #[doc = "< Test Failed"]
    pub const ARM_MATH_TEST_FAILURE: Type = -6;
}
#[doc = " @brief 8-bit fractional data type in 1.7 format."]
pub type q7_t = i8;
#[doc = " @brief 16-bit fractional data type in 1.15 format."]
pub type q15_t = i16;
#[doc = " @brief 32-bit fractional data type in 1.31 format."]
pub type q31_t = i32;
#[doc = " @brief 64-bit fractional data type in 1.63 format."]
pub type q63_t = i64;
#[doc = " @brief 32-bit floating-point type definition."]
pub type float32_t = f32;
#[doc = " @brief 64-bit floating-point type definition."]
pub type float64_t = f64;
#[doc = " @brief Instance structure for the Q7 FIR filter."]
#[repr(C)]
pub struct arm_fir_instance_q7 {
    #[doc = "< number of filter coefficients in the filter."]
    pub numTaps: u16,
    #[doc = "< points to the state variable array. The array is of length numTaps+blockSize-1."]
    pub pState: *mut q7_t,
    #[doc = "< points to the coefficient array. The array is of length numTaps."]
    pub pCoeffs: *const q7_t,
}
#[test]
fn bindgen_test_layout_arm_fir_instance_q7() {
    assert_eq!(
        ::core::mem::size_of::<arm_fir_instance_q7>(),
        24usize,
        concat!("Size of: ", stringify!(arm_fir_instance_q7))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_fir_instance_q7>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_fir_instance_q7))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_fir_instance_q7>())).numTaps as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_instance_q7),
            "::",
            stringify!(numTaps)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_fir_instance_q7>())).pState as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_instance_q7),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_fir_instance_q7>())).pCoeffs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_instance_q7),
            "::",
            stringify!(pCoeffs)
        )
    );
}
#[doc = " @brief Instance structure for the Q15 FIR filter."]
#[repr(C)]
pub struct arm_fir_instance_q15 {
    #[doc = "< number of filter coefficients in the filter."]
    pub numTaps: u16,
    #[doc = "< points to the state variable array. The array is of length numTaps+blockSize-1."]
    pub pState: *mut q15_t,
    #[doc = "< points to the coefficient array. The array is of length numTaps."]
    pub pCoeffs: *const q15_t,
}
#[test]
fn bindgen_test_layout_arm_fir_instance_q15() {
    assert_eq!(
        ::core::mem::size_of::<arm_fir_instance_q15>(),
        24usize,
        concat!("Size of: ", stringify!(arm_fir_instance_q15))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_fir_instance_q15>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_fir_instance_q15))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_fir_instance_q15>())).numTaps as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_instance_q15),
            "::",
            stringify!(numTaps)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_fir_instance_q15>())).pState as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_instance_q15),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_fir_instance_q15>())).pCoeffs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_instance_q15),
            "::",
            stringify!(pCoeffs)
        )
    );
}
#[doc = " @brief Instance structure for the Q31 FIR filter."]
#[repr(C)]
pub struct arm_fir_instance_q31 {
    #[doc = "< number of filter coefficients in the filter."]
    pub numTaps: u16,
    #[doc = "< points to the state variable array. The array is of length numTaps+blockSize-1."]
    pub pState: *mut q31_t,
    #[doc = "< points to the coefficient array. The array is of length numTaps."]
    pub pCoeffs: *const q31_t,
}
#[test]
fn bindgen_test_layout_arm_fir_instance_q31() {
    assert_eq!(
        ::core::mem::size_of::<arm_fir_instance_q31>(),
        24usize,
        concat!("Size of: ", stringify!(arm_fir_instance_q31))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_fir_instance_q31>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_fir_instance_q31))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_fir_instance_q31>())).numTaps as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_instance_q31),
            "::",
            stringify!(numTaps)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_fir_instance_q31>())).pState as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_instance_q31),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_fir_instance_q31>())).pCoeffs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_instance_q31),
            "::",
            stringify!(pCoeffs)
        )
    );
}
#[doc = " @brief Instance structure for the floating-point FIR filter."]
#[repr(C)]
pub struct arm_fir_instance_f32 {
    #[doc = "< number of filter coefficients in the filter."]
    pub numTaps: u16,
    #[doc = "< points to the state variable array. The array is of length numTaps+blockSize-1."]
    pub pState: *mut float32_t,
    #[doc = "< points to the coefficient array. The array is of length numTaps."]
    pub pCoeffs: *const float32_t,
}
#[test]
fn bindgen_test_layout_arm_fir_instance_f32() {
    assert_eq!(
        ::core::mem::size_of::<arm_fir_instance_f32>(),
        24usize,
        concat!("Size of: ", stringify!(arm_fir_instance_f32))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_fir_instance_f32>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_fir_instance_f32))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_fir_instance_f32>())).numTaps as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_instance_f32),
            "::",
            stringify!(numTaps)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_fir_instance_f32>())).pState as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_instance_f32),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_fir_instance_f32>())).pCoeffs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_instance_f32),
            "::",
            stringify!(pCoeffs)
        )
    );
}
extern "C" {
    #[doc = " @brief Processing function for the Q7 FIR filter."]
    #[doc = " @param[in]  S          points to an instance of the Q7 FIR filter structure."]
    #[doc = " @param[in]  pSrc       points to the block of input data."]
    #[doc = " @param[out] pDst       points to the block of output data."]
    #[doc = " @param[in]  blockSize  number of samples to process."]
    pub fn arm_fir_q7(
        S: *const arm_fir_instance_q7,
        pSrc: *const q7_t,
        pDst: *mut q7_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief  Initialization function for the Q7 FIR filter."]
    #[doc = " @param[in,out] S          points to an instance of the Q7 FIR structure."]
    #[doc = " @param[in]     numTaps    Number of filter coefficients in the filter."]
    #[doc = " @param[in]     pCoeffs    points to the filter coefficients."]
    #[doc = " @param[in]     pState     points to the state buffer."]
    #[doc = " @param[in]     blockSize  number of samples that are processed."]
    pub fn arm_fir_init_q7(
        S: *mut arm_fir_instance_q7,
        numTaps: u16,
        pCoeffs: *const q7_t,
        pState: *mut q7_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Processing function for the Q15 FIR filter."]
    #[doc = " @param[in]  S          points to an instance of the Q15 FIR structure."]
    #[doc = " @param[in]  pSrc       points to the block of input data."]
    #[doc = " @param[out] pDst       points to the block of output data."]
    #[doc = " @param[in]  blockSize  number of samples to process."]
    pub fn arm_fir_q15(
        S: *const arm_fir_instance_q15,
        pSrc: *const q15_t,
        pDst: *mut q15_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Processing function for the fast Q15 FIR filter (fast version)."]
    #[doc = " @param[in]  S          points to an instance of the Q15 FIR filter structure."]
    #[doc = " @param[in]  pSrc       points to the block of input data."]
    #[doc = " @param[out] pDst       points to the block of output data."]
    #[doc = " @param[in]  blockSize  number of samples to process."]
    pub fn arm_fir_fast_q15(
        S: *const arm_fir_instance_q15,
        pSrc: *const q15_t,
        pDst: *mut q15_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief  Initialization function for the Q15 FIR filter."]
    #[doc = " @param[in,out] S          points to an instance of the Q15 FIR filter structure."]
    #[doc = " @param[in]     numTaps    Number of filter coefficients in the filter. Must be even and greater than or equal to 4."]
    #[doc = " @param[in]     pCoeffs    points to the filter coefficients."]
    #[doc = " @param[in]     pState     points to the state buffer."]
    #[doc = " @param[in]     blockSize  number of samples that are processed at a time."]
    #[doc = " @return     The function returns either"]
    #[doc = " <code>ARM_MATH_SUCCESS</code> if initialization was successful or"]
    #[doc = " <code>ARM_MATH_ARGUMENT_ERROR</code> if <code>numTaps</code> is not a supported value."]
    pub fn arm_fir_init_q15(
        S: *mut arm_fir_instance_q15,
        numTaps: u16,
        pCoeffs: *const q15_t,
        pState: *mut q15_t,
        blockSize: u32,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Processing function for the Q31 FIR filter."]
    #[doc = " @param[in]  S          points to an instance of the Q31 FIR filter structure."]
    #[doc = " @param[in]  pSrc       points to the block of input data."]
    #[doc = " @param[out] pDst       points to the block of output data."]
    #[doc = " @param[in]  blockSize  number of samples to process."]
    pub fn arm_fir_q31(
        S: *const arm_fir_instance_q31,
        pSrc: *const q31_t,
        pDst: *mut q31_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Processing function for the fast Q31 FIR filter (fast version)."]
    #[doc = " @param[in]  S          points to an instance of the Q31 FIR filter structure."]
    #[doc = " @param[in]  pSrc       points to the block of input data."]
    #[doc = " @param[out] pDst       points to the block of output data."]
    #[doc = " @param[in]  blockSize  number of samples to process."]
    pub fn arm_fir_fast_q31(
        S: *const arm_fir_instance_q31,
        pSrc: *const q31_t,
        pDst: *mut q31_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief  Initialization function for the Q31 FIR filter."]
    #[doc = " @param[in,out] S          points to an instance of the Q31 FIR structure."]
    #[doc = " @param[in]     numTaps    Number of filter coefficients in the filter."]
    #[doc = " @param[in]     pCoeffs    points to the filter coefficients."]
    #[doc = " @param[in]     pState     points to the state buffer."]
    #[doc = " @param[in]     blockSize  number of samples that are processed at a time."]
    pub fn arm_fir_init_q31(
        S: *mut arm_fir_instance_q31,
        numTaps: u16,
        pCoeffs: *const q31_t,
        pState: *mut q31_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Processing function for the floating-point FIR filter."]
    #[doc = " @param[in]  S          points to an instance of the floating-point FIR structure."]
    #[doc = " @param[in]  pSrc       points to the block of input data."]
    #[doc = " @param[out] pDst       points to the block of output data."]
    #[doc = " @param[in]  blockSize  number of samples to process."]
    pub fn arm_fir_f32(
        S: *const arm_fir_instance_f32,
        pSrc: *const float32_t,
        pDst: *mut float32_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief  Initialization function for the floating-point FIR filter."]
    #[doc = " @param[in,out] S          points to an instance of the floating-point FIR filter structure."]
    #[doc = " @param[in]     numTaps    Number of filter coefficients in the filter."]
    #[doc = " @param[in]     pCoeffs    points to the filter coefficients."]
    #[doc = " @param[in]     pState     points to the state buffer."]
    #[doc = " @param[in]     blockSize  number of samples that are processed at a time."]
    pub fn arm_fir_init_f32(
        S: *mut arm_fir_instance_f32,
        numTaps: u16,
        pCoeffs: *const float32_t,
        pState: *mut float32_t,
        blockSize: u32,
    );
}
#[doc = " @brief Instance structure for the Q15 Biquad cascade filter."]
#[repr(C)]
pub struct arm_biquad_casd_df1_inst_q15 {
    #[doc = "< number of 2nd order stages in the filter.  Overall order is 2*numStages."]
    pub numStages: i8,
    #[doc = "< Points to the array of state coefficients.  The array is of length 4*numStages."]
    pub pState: *mut q15_t,
    #[doc = "< Points to the array of coefficients.  The array is of length 5*numStages."]
    pub pCoeffs: *const q15_t,
    #[doc = "< Additional shift, in bits, applied to each output sample."]
    pub postShift: i8,
}
#[test]
fn bindgen_test_layout_arm_biquad_casd_df1_inst_q15() {
    assert_eq!(
        ::core::mem::size_of::<arm_biquad_casd_df1_inst_q15>(),
        32usize,
        concat!("Size of: ", stringify!(arm_biquad_casd_df1_inst_q15))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_biquad_casd_df1_inst_q15>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_biquad_casd_df1_inst_q15))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_biquad_casd_df1_inst_q15>())).numStages as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_biquad_casd_df1_inst_q15),
            "::",
            stringify!(numStages)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_biquad_casd_df1_inst_q15>())).pState as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_biquad_casd_df1_inst_q15),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_biquad_casd_df1_inst_q15>())).pCoeffs as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_biquad_casd_df1_inst_q15),
            "::",
            stringify!(pCoeffs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_biquad_casd_df1_inst_q15>())).postShift as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_biquad_casd_df1_inst_q15),
            "::",
            stringify!(postShift)
        )
    );
}
#[doc = " @brief Instance structure for the Q31 Biquad cascade filter."]
#[repr(C)]
pub struct arm_biquad_casd_df1_inst_q31 {
    #[doc = "< number of 2nd order stages in the filter.  Overall order is 2*numStages."]
    pub numStages: u32,
    #[doc = "< Points to the array of state coefficients.  The array is of length 4*numStages."]
    pub pState: *mut q31_t,
    #[doc = "< Points to the array of coefficients.  The array is of length 5*numStages."]
    pub pCoeffs: *const q31_t,
    #[doc = "< Additional shift, in bits, applied to each output sample."]
    pub postShift: u8,
}
#[test]
fn bindgen_test_layout_arm_biquad_casd_df1_inst_q31() {
    assert_eq!(
        ::core::mem::size_of::<arm_biquad_casd_df1_inst_q31>(),
        32usize,
        concat!("Size of: ", stringify!(arm_biquad_casd_df1_inst_q31))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_biquad_casd_df1_inst_q31>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_biquad_casd_df1_inst_q31))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_biquad_casd_df1_inst_q31>())).numStages as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_biquad_casd_df1_inst_q31),
            "::",
            stringify!(numStages)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_biquad_casd_df1_inst_q31>())).pState as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_biquad_casd_df1_inst_q31),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_biquad_casd_df1_inst_q31>())).pCoeffs as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_biquad_casd_df1_inst_q31),
            "::",
            stringify!(pCoeffs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_biquad_casd_df1_inst_q31>())).postShift as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_biquad_casd_df1_inst_q31),
            "::",
            stringify!(postShift)
        )
    );
}
#[doc = " @brief Instance structure for the floating-point Biquad cascade filter."]
#[repr(C)]
pub struct arm_biquad_casd_df1_inst_f32 {
    #[doc = "< number of 2nd order stages in the filter.  Overall order is 2*numStages."]
    pub numStages: u32,
    #[doc = "< Points to the array of state coefficients.  The array is of length 4*numStages."]
    pub pState: *mut float32_t,
    #[doc = "< Points to the array of coefficients.  The array is of length 5*numStages."]
    pub pCoeffs: *const float32_t,
}
#[test]
fn bindgen_test_layout_arm_biquad_casd_df1_inst_f32() {
    assert_eq!(
        ::core::mem::size_of::<arm_biquad_casd_df1_inst_f32>(),
        24usize,
        concat!("Size of: ", stringify!(arm_biquad_casd_df1_inst_f32))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_biquad_casd_df1_inst_f32>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_biquad_casd_df1_inst_f32))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_biquad_casd_df1_inst_f32>())).numStages as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_biquad_casd_df1_inst_f32),
            "::",
            stringify!(numStages)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_biquad_casd_df1_inst_f32>())).pState as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_biquad_casd_df1_inst_f32),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_biquad_casd_df1_inst_f32>())).pCoeffs as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_biquad_casd_df1_inst_f32),
            "::",
            stringify!(pCoeffs)
        )
    );
}
extern "C" {
    #[doc = " @brief Processing function for the Q15 Biquad cascade filter."]
    #[doc = " @param[in]  S          points to an instance of the Q15 Biquad cascade structure."]
    #[doc = " @param[in]  pSrc       points to the block of input data."]
    #[doc = " @param[out] pDst       points to the block of output data."]
    #[doc = " @param[in]  blockSize  number of samples to process."]
    pub fn arm_biquad_cascade_df1_q15(
        S: *const arm_biquad_casd_df1_inst_q15,
        pSrc: *const q15_t,
        pDst: *mut q15_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief  Initialization function for the Q15 Biquad cascade filter."]
    #[doc = " @param[in,out] S          points to an instance of the Q15 Biquad cascade structure."]
    #[doc = " @param[in]     numStages  number of 2nd order stages in the filter."]
    #[doc = " @param[in]     pCoeffs    points to the filter coefficients."]
    #[doc = " @param[in]     pState     points to the state buffer."]
    #[doc = " @param[in]     postShift  Shift to be applied to the output. Varies according to the coefficients format"]
    pub fn arm_biquad_cascade_df1_init_q15(
        S: *mut arm_biquad_casd_df1_inst_q15,
        numStages: u8,
        pCoeffs: *const q15_t,
        pState: *mut q15_t,
        postShift: i8,
    );
}
extern "C" {
    #[doc = " @brief Fast but less precise processing function for the Q15 Biquad cascade filter for Cortex-M3 and Cortex-M4."]
    #[doc = " @param[in]  S          points to an instance of the Q15 Biquad cascade structure."]
    #[doc = " @param[in]  pSrc       points to the block of input data."]
    #[doc = " @param[out] pDst       points to the block of output data."]
    #[doc = " @param[in]  blockSize  number of samples to process."]
    pub fn arm_biquad_cascade_df1_fast_q15(
        S: *const arm_biquad_casd_df1_inst_q15,
        pSrc: *const q15_t,
        pDst: *mut q15_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Processing function for the Q31 Biquad cascade filter"]
    #[doc = " @param[in]  S          points to an instance of the Q31 Biquad cascade structure."]
    #[doc = " @param[in]  pSrc       points to the block of input data."]
    #[doc = " @param[out] pDst       points to the block of output data."]
    #[doc = " @param[in]  blockSize  number of samples to process."]
    pub fn arm_biquad_cascade_df1_q31(
        S: *const arm_biquad_casd_df1_inst_q31,
        pSrc: *const q31_t,
        pDst: *mut q31_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Fast but less precise processing function for the Q31 Biquad cascade filter for Cortex-M3 and Cortex-M4."]
    #[doc = " @param[in]  S          points to an instance of the Q31 Biquad cascade structure."]
    #[doc = " @param[in]  pSrc       points to the block of input data."]
    #[doc = " @param[out] pDst       points to the block of output data."]
    #[doc = " @param[in]  blockSize  number of samples to process."]
    pub fn arm_biquad_cascade_df1_fast_q31(
        S: *const arm_biquad_casd_df1_inst_q31,
        pSrc: *const q31_t,
        pDst: *mut q31_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief  Initialization function for the Q31 Biquad cascade filter."]
    #[doc = " @param[in,out] S          points to an instance of the Q31 Biquad cascade structure."]
    #[doc = " @param[in]     numStages  number of 2nd order stages in the filter."]
    #[doc = " @param[in]     pCoeffs    points to the filter coefficients."]
    #[doc = " @param[in]     pState     points to the state buffer."]
    #[doc = " @param[in]     postShift  Shift to be applied to the output. Varies according to the coefficients format"]
    pub fn arm_biquad_cascade_df1_init_q31(
        S: *mut arm_biquad_casd_df1_inst_q31,
        numStages: u8,
        pCoeffs: *const q31_t,
        pState: *mut q31_t,
        postShift: i8,
    );
}
extern "C" {
    #[doc = " @brief Processing function for the floating-point Biquad cascade filter."]
    #[doc = " @param[in]  S          points to an instance of the floating-point Biquad cascade structure."]
    #[doc = " @param[in]  pSrc       points to the block of input data."]
    #[doc = " @param[out] pDst       points to the block of output data."]
    #[doc = " @param[in]  blockSize  number of samples to process."]
    pub fn arm_biquad_cascade_df1_f32(
        S: *const arm_biquad_casd_df1_inst_f32,
        pSrc: *const float32_t,
        pDst: *mut float32_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief  Initialization function for the floating-point Biquad cascade filter."]
    #[doc = " @param[in,out] S          points to an instance of the floating-point Biquad cascade structure."]
    #[doc = " @param[in]     numStages  number of 2nd order stages in the filter."]
    #[doc = " @param[in]     pCoeffs    points to the filter coefficients."]
    #[doc = " @param[in]     pState     points to the state buffer."]
    pub fn arm_biquad_cascade_df1_init_f32(
        S: *mut arm_biquad_casd_df1_inst_f32,
        numStages: u8,
        pCoeffs: *const float32_t,
        pState: *mut float32_t,
    );
}
#[doc = " @brief Instance structure for the floating-point matrix structure."]
#[repr(C)]
pub struct arm_matrix_instance_f32 {
    #[doc = "< number of rows of the matrix."]
    pub numRows: u16,
    #[doc = "< number of columns of the matrix."]
    pub numCols: u16,
    #[doc = "< points to the data of the matrix."]
    pub pData: *mut float32_t,
}
#[test]
fn bindgen_test_layout_arm_matrix_instance_f32() {
    assert_eq!(
        ::core::mem::size_of::<arm_matrix_instance_f32>(),
        16usize,
        concat!("Size of: ", stringify!(arm_matrix_instance_f32))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_matrix_instance_f32>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_matrix_instance_f32))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_matrix_instance_f32>())).numRows as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_matrix_instance_f32),
            "::",
            stringify!(numRows)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_matrix_instance_f32>())).numCols as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_matrix_instance_f32),
            "::",
            stringify!(numCols)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_matrix_instance_f32>())).pData as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_matrix_instance_f32),
            "::",
            stringify!(pData)
        )
    );
}
#[doc = " @brief Instance structure for the floating-point matrix structure."]
#[repr(C)]
pub struct arm_matrix_instance_f64 {
    #[doc = "< number of rows of the matrix."]
    pub numRows: u16,
    #[doc = "< number of columns of the matrix."]
    pub numCols: u16,
    #[doc = "< points to the data of the matrix."]
    pub pData: *mut float64_t,
}
#[test]
fn bindgen_test_layout_arm_matrix_instance_f64() {
    assert_eq!(
        ::core::mem::size_of::<arm_matrix_instance_f64>(),
        16usize,
        concat!("Size of: ", stringify!(arm_matrix_instance_f64))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_matrix_instance_f64>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_matrix_instance_f64))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_matrix_instance_f64>())).numRows as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_matrix_instance_f64),
            "::",
            stringify!(numRows)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_matrix_instance_f64>())).numCols as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_matrix_instance_f64),
            "::",
            stringify!(numCols)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_matrix_instance_f64>())).pData as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_matrix_instance_f64),
            "::",
            stringify!(pData)
        )
    );
}
#[doc = " @brief Instance structure for the Q15 matrix structure."]
#[repr(C)]
pub struct arm_matrix_instance_q15 {
    #[doc = "< number of rows of the matrix."]
    pub numRows: u16,
    #[doc = "< number of columns of the matrix."]
    pub numCols: u16,
    #[doc = "< points to the data of the matrix."]
    pub pData: *mut q15_t,
}
#[test]
fn bindgen_test_layout_arm_matrix_instance_q15() {
    assert_eq!(
        ::core::mem::size_of::<arm_matrix_instance_q15>(),
        16usize,
        concat!("Size of: ", stringify!(arm_matrix_instance_q15))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_matrix_instance_q15>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_matrix_instance_q15))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_matrix_instance_q15>())).numRows as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_matrix_instance_q15),
            "::",
            stringify!(numRows)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_matrix_instance_q15>())).numCols as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_matrix_instance_q15),
            "::",
            stringify!(numCols)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_matrix_instance_q15>())).pData as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_matrix_instance_q15),
            "::",
            stringify!(pData)
        )
    );
}
#[doc = " @brief Instance structure for the Q31 matrix structure."]
#[repr(C)]
pub struct arm_matrix_instance_q31 {
    #[doc = "< number of rows of the matrix."]
    pub numRows: u16,
    #[doc = "< number of columns of the matrix."]
    pub numCols: u16,
    #[doc = "< points to the data of the matrix."]
    pub pData: *mut q31_t,
}
#[test]
fn bindgen_test_layout_arm_matrix_instance_q31() {
    assert_eq!(
        ::core::mem::size_of::<arm_matrix_instance_q31>(),
        16usize,
        concat!("Size of: ", stringify!(arm_matrix_instance_q31))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_matrix_instance_q31>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_matrix_instance_q31))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_matrix_instance_q31>())).numRows as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_matrix_instance_q31),
            "::",
            stringify!(numRows)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_matrix_instance_q31>())).numCols as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_matrix_instance_q31),
            "::",
            stringify!(numCols)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_matrix_instance_q31>())).pData as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_matrix_instance_q31),
            "::",
            stringify!(pData)
        )
    );
}
extern "C" {
    #[doc = " @brief Floating-point matrix addition."]
    #[doc = " @param[in]  pSrcA  points to the first input matrix structure"]
    #[doc = " @param[in]  pSrcB  points to the second input matrix structure"]
    #[doc = " @param[out] pDst   points to output matrix structure"]
    #[doc = " @return     The function returns either"]
    #[doc = " <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking."]
    pub fn arm_mat_add_f32(
        pSrcA: *const arm_matrix_instance_f32,
        pSrcB: *const arm_matrix_instance_f32,
        pDst: *mut arm_matrix_instance_f32,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Q15 matrix addition."]
    #[doc = " @param[in]   pSrcA  points to the first input matrix structure"]
    #[doc = " @param[in]   pSrcB  points to the second input matrix structure"]
    #[doc = " @param[out]  pDst   points to output matrix structure"]
    #[doc = " @return     The function returns either"]
    #[doc = " <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking."]
    pub fn arm_mat_add_q15(
        pSrcA: *const arm_matrix_instance_q15,
        pSrcB: *const arm_matrix_instance_q15,
        pDst: *mut arm_matrix_instance_q15,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Q31 matrix addition."]
    #[doc = " @param[in]  pSrcA  points to the first input matrix structure"]
    #[doc = " @param[in]  pSrcB  points to the second input matrix structure"]
    #[doc = " @param[out] pDst   points to output matrix structure"]
    #[doc = " @return     The function returns either"]
    #[doc = " <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking."]
    pub fn arm_mat_add_q31(
        pSrcA: *const arm_matrix_instance_q31,
        pSrcB: *const arm_matrix_instance_q31,
        pDst: *mut arm_matrix_instance_q31,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Floating-point, complex, matrix multiplication."]
    #[doc = " @param[in]  pSrcA  points to the first input matrix structure"]
    #[doc = " @param[in]  pSrcB  points to the second input matrix structure"]
    #[doc = " @param[out] pDst   points to output matrix structure"]
    #[doc = " @return     The function returns either"]
    #[doc = " <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking."]
    pub fn arm_mat_cmplx_mult_f32(
        pSrcA: *const arm_matrix_instance_f32,
        pSrcB: *const arm_matrix_instance_f32,
        pDst: *mut arm_matrix_instance_f32,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Q15, complex,  matrix multiplication."]
    #[doc = " @param[in]  pSrcA  points to the first input matrix structure"]
    #[doc = " @param[in]  pSrcB  points to the second input matrix structure"]
    #[doc = " @param[out] pDst   points to output matrix structure"]
    #[doc = " @return     The function returns either"]
    #[doc = " <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking."]
    pub fn arm_mat_cmplx_mult_q15(
        pSrcA: *const arm_matrix_instance_q15,
        pSrcB: *const arm_matrix_instance_q15,
        pDst: *mut arm_matrix_instance_q15,
        pScratch: *mut q15_t,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Q31, complex, matrix multiplication."]
    #[doc = " @param[in]  pSrcA  points to the first input matrix structure"]
    #[doc = " @param[in]  pSrcB  points to the second input matrix structure"]
    #[doc = " @param[out] pDst   points to output matrix structure"]
    #[doc = " @return     The function returns either"]
    #[doc = " <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking."]
    pub fn arm_mat_cmplx_mult_q31(
        pSrcA: *const arm_matrix_instance_q31,
        pSrcB: *const arm_matrix_instance_q31,
        pDst: *mut arm_matrix_instance_q31,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Floating-point matrix transpose."]
    #[doc = " @param[in]  pSrc  points to the input matrix"]
    #[doc = " @param[out] pDst  points to the output matrix"]
    #[doc = " @return    The function returns either  <code>ARM_MATH_SIZE_MISMATCH</code>"]
    #[doc = " or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking."]
    pub fn arm_mat_trans_f32(
        pSrc: *const arm_matrix_instance_f32,
        pDst: *mut arm_matrix_instance_f32,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Q15 matrix transpose."]
    #[doc = " @param[in]  pSrc  points to the input matrix"]
    #[doc = " @param[out] pDst  points to the output matrix"]
    #[doc = " @return    The function returns either  <code>ARM_MATH_SIZE_MISMATCH</code>"]
    #[doc = " or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking."]
    pub fn arm_mat_trans_q15(
        pSrc: *const arm_matrix_instance_q15,
        pDst: *mut arm_matrix_instance_q15,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Q31 matrix transpose."]
    #[doc = " @param[in]  pSrc  points to the input matrix"]
    #[doc = " @param[out] pDst  points to the output matrix"]
    #[doc = " @return    The function returns either  <code>ARM_MATH_SIZE_MISMATCH</code>"]
    #[doc = " or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking."]
    pub fn arm_mat_trans_q31(
        pSrc: *const arm_matrix_instance_q31,
        pDst: *mut arm_matrix_instance_q31,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Floating-point matrix multiplication"]
    #[doc = " @param[in]  pSrcA  points to the first input matrix structure"]
    #[doc = " @param[in]  pSrcB  points to the second input matrix structure"]
    #[doc = " @param[out] pDst   points to output matrix structure"]
    #[doc = " @return     The function returns either"]
    #[doc = " <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking."]
    pub fn arm_mat_mult_f32(
        pSrcA: *const arm_matrix_instance_f32,
        pSrcB: *const arm_matrix_instance_f32,
        pDst: *mut arm_matrix_instance_f32,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Q15 matrix multiplication"]
    #[doc = " @param[in]  pSrcA   points to the first input matrix structure"]
    #[doc = " @param[in]  pSrcB   points to the second input matrix structure"]
    #[doc = " @param[out] pDst    points to output matrix structure"]
    #[doc = " @param[in]  pState  points to the array for storing intermediate results"]
    #[doc = " @return     The function returns either"]
    #[doc = " <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking."]
    pub fn arm_mat_mult_q15(
        pSrcA: *const arm_matrix_instance_q15,
        pSrcB: *const arm_matrix_instance_q15,
        pDst: *mut arm_matrix_instance_q15,
        pState: *mut q15_t,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Q15 matrix multiplication (fast variant) for Cortex-M3 and Cortex-M4"]
    #[doc = " @param[in]  pSrcA   points to the first input matrix structure"]
    #[doc = " @param[in]  pSrcB   points to the second input matrix structure"]
    #[doc = " @param[out] pDst    points to output matrix structure"]
    #[doc = " @param[in]  pState  points to the array for storing intermediate results"]
    #[doc = " @return     The function returns either"]
    #[doc = " <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking."]
    pub fn arm_mat_mult_fast_q15(
        pSrcA: *const arm_matrix_instance_q15,
        pSrcB: *const arm_matrix_instance_q15,
        pDst: *mut arm_matrix_instance_q15,
        pState: *mut q15_t,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Q31 matrix multiplication"]
    #[doc = " @param[in]  pSrcA  points to the first input matrix structure"]
    #[doc = " @param[in]  pSrcB  points to the second input matrix structure"]
    #[doc = " @param[out] pDst   points to output matrix structure"]
    #[doc = " @return     The function returns either"]
    #[doc = " <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking."]
    pub fn arm_mat_mult_q31(
        pSrcA: *const arm_matrix_instance_q31,
        pSrcB: *const arm_matrix_instance_q31,
        pDst: *mut arm_matrix_instance_q31,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Q31 matrix multiplication (fast variant) for Cortex-M3 and Cortex-M4"]
    #[doc = " @param[in]  pSrcA  points to the first input matrix structure"]
    #[doc = " @param[in]  pSrcB  points to the second input matrix structure"]
    #[doc = " @param[out] pDst   points to output matrix structure"]
    #[doc = " @return     The function returns either"]
    #[doc = " <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking."]
    pub fn arm_mat_mult_fast_q31(
        pSrcA: *const arm_matrix_instance_q31,
        pSrcB: *const arm_matrix_instance_q31,
        pDst: *mut arm_matrix_instance_q31,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Floating-point matrix subtraction"]
    #[doc = " @param[in]  pSrcA  points to the first input matrix structure"]
    #[doc = " @param[in]  pSrcB  points to the second input matrix structure"]
    #[doc = " @param[out] pDst   points to output matrix structure"]
    #[doc = " @return     The function returns either"]
    #[doc = " <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking."]
    pub fn arm_mat_sub_f32(
        pSrcA: *const arm_matrix_instance_f32,
        pSrcB: *const arm_matrix_instance_f32,
        pDst: *mut arm_matrix_instance_f32,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Q15 matrix subtraction"]
    #[doc = " @param[in]  pSrcA  points to the first input matrix structure"]
    #[doc = " @param[in]  pSrcB  points to the second input matrix structure"]
    #[doc = " @param[out] pDst   points to output matrix structure"]
    #[doc = " @return     The function returns either"]
    #[doc = " <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking."]
    pub fn arm_mat_sub_q15(
        pSrcA: *const arm_matrix_instance_q15,
        pSrcB: *const arm_matrix_instance_q15,
        pDst: *mut arm_matrix_instance_q15,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Q31 matrix subtraction"]
    #[doc = " @param[in]  pSrcA  points to the first input matrix structure"]
    #[doc = " @param[in]  pSrcB  points to the second input matrix structure"]
    #[doc = " @param[out] pDst   points to output matrix structure"]
    #[doc = " @return     The function returns either"]
    #[doc = " <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking."]
    pub fn arm_mat_sub_q31(
        pSrcA: *const arm_matrix_instance_q31,
        pSrcB: *const arm_matrix_instance_q31,
        pDst: *mut arm_matrix_instance_q31,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Floating-point matrix scaling."]
    #[doc = " @param[in]  pSrc   points to the input matrix"]
    #[doc = " @param[in]  scale  scale factor"]
    #[doc = " @param[out] pDst   points to the output matrix"]
    #[doc = " @return     The function returns either"]
    #[doc = " <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking."]
    pub fn arm_mat_scale_f32(
        pSrc: *const arm_matrix_instance_f32,
        scale: float32_t,
        pDst: *mut arm_matrix_instance_f32,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Q15 matrix scaling."]
    #[doc = " @param[in]  pSrc        points to input matrix"]
    #[doc = " @param[in]  scaleFract  fractional portion of the scale factor"]
    #[doc = " @param[in]  shift       number of bits to shift the result by"]
    #[doc = " @param[out] pDst        points to output matrix"]
    #[doc = " @return     The function returns either"]
    #[doc = " <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking."]
    pub fn arm_mat_scale_q15(
        pSrc: *const arm_matrix_instance_q15,
        scaleFract: q15_t,
        shift: i32,
        pDst: *mut arm_matrix_instance_q15,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Q31 matrix scaling."]
    #[doc = " @param[in]  pSrc        points to input matrix"]
    #[doc = " @param[in]  scaleFract  fractional portion of the scale factor"]
    #[doc = " @param[in]  shift       number of bits to shift the result by"]
    #[doc = " @param[out] pDst        points to output matrix structure"]
    #[doc = " @return     The function returns either"]
    #[doc = " <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking."]
    pub fn arm_mat_scale_q31(
        pSrc: *const arm_matrix_instance_q31,
        scaleFract: q31_t,
        shift: i32,
        pDst: *mut arm_matrix_instance_q31,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief  Q31 matrix initialization."]
    #[doc = " @param[in,out] S         points to an instance of the floating-point matrix structure."]
    #[doc = " @param[in]     nRows     number of rows in the matrix."]
    #[doc = " @param[in]     nColumns  number of columns in the matrix."]
    #[doc = " @param[in]     pData     points to the matrix data array."]
    pub fn arm_mat_init_q31(
        S: *mut arm_matrix_instance_q31,
        nRows: u16,
        nColumns: u16,
        pData: *mut q31_t,
    );
}
extern "C" {
    #[doc = " @brief  Q15 matrix initialization."]
    #[doc = " @param[in,out] S         points to an instance of the floating-point matrix structure."]
    #[doc = " @param[in]     nRows     number of rows in the matrix."]
    #[doc = " @param[in]     nColumns  number of columns in the matrix."]
    #[doc = " @param[in]     pData     points to the matrix data array."]
    pub fn arm_mat_init_q15(
        S: *mut arm_matrix_instance_q15,
        nRows: u16,
        nColumns: u16,
        pData: *mut q15_t,
    );
}
extern "C" {
    #[doc = " @brief  Floating-point matrix initialization."]
    #[doc = " @param[in,out] S         points to an instance of the floating-point matrix structure."]
    #[doc = " @param[in]     nRows     number of rows in the matrix."]
    #[doc = " @param[in]     nColumns  number of columns in the matrix."]
    #[doc = " @param[in]     pData     points to the matrix data array."]
    pub fn arm_mat_init_f32(
        S: *mut arm_matrix_instance_f32,
        nRows: u16,
        nColumns: u16,
        pData: *mut float32_t,
    );
}
#[doc = " @brief Instance structure for the Q15 PID Control."]
#[repr(C)]
pub struct arm_pid_instance_q15 {
    #[doc = "< The derived gain, A0 = Kp + Ki + Kd ."]
    pub A0: q15_t,
    pub A1: q15_t,
    pub A2: q15_t,
    #[doc = "< The state array of length 3."]
    pub state: [q15_t; 3usize],
    #[doc = "< The proportional gain."]
    pub Kp: q15_t,
    #[doc = "< The integral gain."]
    pub Ki: q15_t,
    #[doc = "< The derivative gain."]
    pub Kd: q15_t,
}
#[test]
fn bindgen_test_layout_arm_pid_instance_q15() {
    assert_eq!(
        ::core::mem::size_of::<arm_pid_instance_q15>(),
        18usize,
        concat!("Size of: ", stringify!(arm_pid_instance_q15))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_pid_instance_q15>(),
        2usize,
        concat!("Alignment of ", stringify!(arm_pid_instance_q15))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_pid_instance_q15>())).A0 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_pid_instance_q15),
            "::",
            stringify!(A0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_pid_instance_q15>())).A1 as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_pid_instance_q15),
            "::",
            stringify!(A1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_pid_instance_q15>())).A2 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_pid_instance_q15),
            "::",
            stringify!(A2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_pid_instance_q15>())).state as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_pid_instance_q15),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_pid_instance_q15>())).Kp as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_pid_instance_q15),
            "::",
            stringify!(Kp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_pid_instance_q15>())).Ki as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_pid_instance_q15),
            "::",
            stringify!(Ki)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_pid_instance_q15>())).Kd as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_pid_instance_q15),
            "::",
            stringify!(Kd)
        )
    );
}
#[doc = " @brief Instance structure for the Q31 PID Control."]
#[repr(C)]
pub struct arm_pid_instance_q31 {
    #[doc = "< The derived gain, A0 = Kp + Ki + Kd ."]
    pub A0: q31_t,
    #[doc = "< The derived gain, A1 = -Kp - 2Kd."]
    pub A1: q31_t,
    #[doc = "< The derived gain, A2 = Kd ."]
    pub A2: q31_t,
    #[doc = "< The state array of length 3."]
    pub state: [q31_t; 3usize],
    #[doc = "< The proportional gain."]
    pub Kp: q31_t,
    #[doc = "< The integral gain."]
    pub Ki: q31_t,
    #[doc = "< The derivative gain."]
    pub Kd: q31_t,
}
#[test]
fn bindgen_test_layout_arm_pid_instance_q31() {
    assert_eq!(
        ::core::mem::size_of::<arm_pid_instance_q31>(),
        36usize,
        concat!("Size of: ", stringify!(arm_pid_instance_q31))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_pid_instance_q31>(),
        4usize,
        concat!("Alignment of ", stringify!(arm_pid_instance_q31))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_pid_instance_q31>())).A0 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_pid_instance_q31),
            "::",
            stringify!(A0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_pid_instance_q31>())).A1 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_pid_instance_q31),
            "::",
            stringify!(A1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_pid_instance_q31>())).A2 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_pid_instance_q31),
            "::",
            stringify!(A2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_pid_instance_q31>())).state as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_pid_instance_q31),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_pid_instance_q31>())).Kp as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_pid_instance_q31),
            "::",
            stringify!(Kp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_pid_instance_q31>())).Ki as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_pid_instance_q31),
            "::",
            stringify!(Ki)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_pid_instance_q31>())).Kd as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_pid_instance_q31),
            "::",
            stringify!(Kd)
        )
    );
}
#[doc = " @brief Instance structure for the floating-point PID Control."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct arm_pid_instance_f32 {
    #[doc = "< The derived gain, A0 = Kp + Ki + Kd ."]
    pub A0: float32_t,
    #[doc = "< The derived gain, A1 = -Kp - 2Kd."]
    pub A1: float32_t,
    #[doc = "< The derived gain, A2 = Kd ."]
    pub A2: float32_t,
    #[doc = "< The state array of length 3."]
    pub state: [float32_t; 3usize],
    #[doc = "< The proportional gain."]
    pub Kp: float32_t,
    #[doc = "< The integral gain."]
    pub Ki: float32_t,
    #[doc = "< The derivative gain."]
    pub Kd: float32_t,
}
#[test]
fn bindgen_test_layout_arm_pid_instance_f32() {
    assert_eq!(
        ::core::mem::size_of::<arm_pid_instance_f32>(),
        36usize,
        concat!("Size of: ", stringify!(arm_pid_instance_f32))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_pid_instance_f32>(),
        4usize,
        concat!("Alignment of ", stringify!(arm_pid_instance_f32))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_pid_instance_f32>())).A0 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_pid_instance_f32),
            "::",
            stringify!(A0)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_pid_instance_f32>())).A1 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_pid_instance_f32),
            "::",
            stringify!(A1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_pid_instance_f32>())).A2 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_pid_instance_f32),
            "::",
            stringify!(A2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_pid_instance_f32>())).state as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_pid_instance_f32),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_pid_instance_f32>())).Kp as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_pid_instance_f32),
            "::",
            stringify!(Kp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_pid_instance_f32>())).Ki as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_pid_instance_f32),
            "::",
            stringify!(Ki)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_pid_instance_f32>())).Kd as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_pid_instance_f32),
            "::",
            stringify!(Kd)
        )
    );
}
extern "C" {
    #[doc = " @brief  Initialization function for the floating-point PID Control."]
    #[doc = " @param[in,out] S               points to an instance of the PID structure."]
    #[doc = " @param[in]     resetStateFlag  flag to reset the state. 0 = no change in state 1 = reset the state."]
    pub fn arm_pid_init_f32(S: *mut arm_pid_instance_f32, resetStateFlag: i32);
}
extern "C" {
    #[doc = " @brief  Reset function for the floating-point PID Control."]
    #[doc = " @param[in,out] S  is an instance of the floating-point PID Control structure"]
    pub fn arm_pid_reset_f32(S: *mut arm_pid_instance_f32);
}
extern "C" {
    #[doc = " @brief  Initialization function for the Q31 PID Control."]
    #[doc = " @param[in,out] S               points to an instance of the Q15 PID structure."]
    #[doc = " @param[in]     resetStateFlag  flag to reset the state. 0 = no change in state 1 = reset the state."]
    pub fn arm_pid_init_q31(S: *mut arm_pid_instance_q31, resetStateFlag: i32);
}
extern "C" {
    #[doc = " @brief  Reset function for the Q31 PID Control."]
    #[doc = " @param[in,out] S   points to an instance of the Q31 PID Control structure"]
    pub fn arm_pid_reset_q31(S: *mut arm_pid_instance_q31);
}
extern "C" {
    #[doc = " @brief  Initialization function for the Q15 PID Control."]
    #[doc = " @param[in,out] S               points to an instance of the Q15 PID structure."]
    #[doc = " @param[in]     resetStateFlag  flag to reset the state. 0 = no change in state 1 = reset the state."]
    pub fn arm_pid_init_q15(S: *mut arm_pid_instance_q15, resetStateFlag: i32);
}
extern "C" {
    #[doc = " @brief  Reset function for the Q15 PID Control."]
    #[doc = " @param[in,out] S  points to an instance of the q15 PID Control structure"]
    pub fn arm_pid_reset_q15(S: *mut arm_pid_instance_q15);
}
extern "C" {
    #[doc = " @brief Q7 vector multiplication."]
    #[doc = " @param[in]  pSrcA      points to the first input vector"]
    #[doc = " @param[in]  pSrcB      points to the second input vector"]
    #[doc = " @param[out] pDst       points to the output vector"]
    #[doc = " @param[in]  blockSize  number of samples in each vector"]
    pub fn arm_mult_q7(pSrcA: *const q7_t, pSrcB: *const q7_t, pDst: *mut q7_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief Q15 vector multiplication."]
    #[doc = " @param[in]  pSrcA      points to the first input vector"]
    #[doc = " @param[in]  pSrcB      points to the second input vector"]
    #[doc = " @param[out] pDst       points to the output vector"]
    #[doc = " @param[in]  blockSize  number of samples in each vector"]
    pub fn arm_mult_q15(pSrcA: *const q15_t, pSrcB: *const q15_t, pDst: *mut q15_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief Q31 vector multiplication."]
    #[doc = " @param[in]  pSrcA      points to the first input vector"]
    #[doc = " @param[in]  pSrcB      points to the second input vector"]
    #[doc = " @param[out] pDst       points to the output vector"]
    #[doc = " @param[in]  blockSize  number of samples in each vector"]
    pub fn arm_mult_q31(pSrcA: *const q31_t, pSrcB: *const q31_t, pDst: *mut q31_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief Floating-point vector multiplication."]
    #[doc = " @param[in]  pSrcA      points to the first input vector"]
    #[doc = " @param[in]  pSrcB      points to the second input vector"]
    #[doc = " @param[out] pDst       points to the output vector"]
    #[doc = " @param[in]  blockSize  number of samples in each vector"]
    pub fn arm_mult_f32(
        pSrcA: *const float32_t,
        pSrcB: *const float32_t,
        pDst: *mut float32_t,
        blockSize: u32,
    );
}
#[doc = " @brief Instance structure for the Q15 CFFT/CIFFT function."]
#[repr(C)]
pub struct arm_cfft_radix2_instance_q15 {
    #[doc = "< length of the FFT."]
    pub fftLen: u16,
    #[doc = "< flag that selects forward (ifftFlag=0) or inverse (ifftFlag=1) transform."]
    pub ifftFlag: u8,
    #[doc = "< flag that enables (bitReverseFlag=1) or disables (bitReverseFlag=0) bit reversal of output."]
    pub bitReverseFlag: u8,
    #[doc = "< points to the Sin twiddle factor table."]
    pub pTwiddle: *const q15_t,
    #[doc = "< points to the bit reversal table."]
    pub pBitRevTable: *const u16,
    #[doc = "< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table."]
    pub twidCoefModifier: u16,
    #[doc = "< bit reversal modifier that supports different size FFTs with the same bit reversal table."]
    pub bitRevFactor: u16,
}
#[test]
fn bindgen_test_layout_arm_cfft_radix2_instance_q15() {
    assert_eq!(
        ::core::mem::size_of::<arm_cfft_radix2_instance_q15>(),
        32usize,
        concat!("Size of: ", stringify!(arm_cfft_radix2_instance_q15))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_cfft_radix2_instance_q15>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_cfft_radix2_instance_q15))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix2_instance_q15>())).fftLen as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix2_instance_q15),
            "::",
            stringify!(fftLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix2_instance_q15>())).ifftFlag as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix2_instance_q15),
            "::",
            stringify!(ifftFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix2_instance_q15>())).bitReverseFlag as *const _
                as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix2_instance_q15),
            "::",
            stringify!(bitReverseFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix2_instance_q15>())).pTwiddle as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix2_instance_q15),
            "::",
            stringify!(pTwiddle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix2_instance_q15>())).pBitRevTable as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix2_instance_q15),
            "::",
            stringify!(pBitRevTable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix2_instance_q15>())).twidCoefModifier as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix2_instance_q15),
            "::",
            stringify!(twidCoefModifier)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix2_instance_q15>())).bitRevFactor as *const _
                as usize
        },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix2_instance_q15),
            "::",
            stringify!(bitRevFactor)
        )
    );
}
extern "C" {
    pub fn arm_cfft_radix2_init_q15(
        S: *mut arm_cfft_radix2_instance_q15,
        fftLen: u16,
        ifftFlag: u8,
        bitReverseFlag: u8,
    ) -> arm_status::Type;
}
extern "C" {
    pub fn arm_cfft_radix2_q15(S: *const arm_cfft_radix2_instance_q15, pSrc: *mut q15_t);
}
#[doc = " @brief Instance structure for the Q15 CFFT/CIFFT function."]
#[repr(C)]
pub struct arm_cfft_radix4_instance_q15 {
    #[doc = "< length of the FFT."]
    pub fftLen: u16,
    #[doc = "< flag that selects forward (ifftFlag=0) or inverse (ifftFlag=1) transform."]
    pub ifftFlag: u8,
    #[doc = "< flag that enables (bitReverseFlag=1) or disables (bitReverseFlag=0) bit reversal of output."]
    pub bitReverseFlag: u8,
    #[doc = "< points to the twiddle factor table."]
    pub pTwiddle: *const q15_t,
    #[doc = "< points to the bit reversal table."]
    pub pBitRevTable: *const u16,
    #[doc = "< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table."]
    pub twidCoefModifier: u16,
    #[doc = "< bit reversal modifier that supports different size FFTs with the same bit reversal table."]
    pub bitRevFactor: u16,
}
#[test]
fn bindgen_test_layout_arm_cfft_radix4_instance_q15() {
    assert_eq!(
        ::core::mem::size_of::<arm_cfft_radix4_instance_q15>(),
        32usize,
        concat!("Size of: ", stringify!(arm_cfft_radix4_instance_q15))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_cfft_radix4_instance_q15>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_cfft_radix4_instance_q15))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix4_instance_q15>())).fftLen as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix4_instance_q15),
            "::",
            stringify!(fftLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix4_instance_q15>())).ifftFlag as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix4_instance_q15),
            "::",
            stringify!(ifftFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix4_instance_q15>())).bitReverseFlag as *const _
                as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix4_instance_q15),
            "::",
            stringify!(bitReverseFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix4_instance_q15>())).pTwiddle as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix4_instance_q15),
            "::",
            stringify!(pTwiddle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix4_instance_q15>())).pBitRevTable as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix4_instance_q15),
            "::",
            stringify!(pBitRevTable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix4_instance_q15>())).twidCoefModifier as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix4_instance_q15),
            "::",
            stringify!(twidCoefModifier)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix4_instance_q15>())).bitRevFactor as *const _
                as usize
        },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix4_instance_q15),
            "::",
            stringify!(bitRevFactor)
        )
    );
}
extern "C" {
    pub fn arm_cfft_radix4_init_q15(
        S: *mut arm_cfft_radix4_instance_q15,
        fftLen: u16,
        ifftFlag: u8,
        bitReverseFlag: u8,
    ) -> arm_status::Type;
}
extern "C" {
    pub fn arm_cfft_radix4_q15(S: *const arm_cfft_radix4_instance_q15, pSrc: *mut q15_t);
}
#[doc = " @brief Instance structure for the Radix-2 Q31 CFFT/CIFFT function."]
#[repr(C)]
pub struct arm_cfft_radix2_instance_q31 {
    #[doc = "< length of the FFT."]
    pub fftLen: u16,
    #[doc = "< flag that selects forward (ifftFlag=0) or inverse (ifftFlag=1) transform."]
    pub ifftFlag: u8,
    #[doc = "< flag that enables (bitReverseFlag=1) or disables (bitReverseFlag=0) bit reversal of output."]
    pub bitReverseFlag: u8,
    #[doc = "< points to the Twiddle factor table."]
    pub pTwiddle: *const q31_t,
    #[doc = "< points to the bit reversal table."]
    pub pBitRevTable: *const u16,
    #[doc = "< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table."]
    pub twidCoefModifier: u16,
    #[doc = "< bit reversal modifier that supports different size FFTs with the same bit reversal table."]
    pub bitRevFactor: u16,
}
#[test]
fn bindgen_test_layout_arm_cfft_radix2_instance_q31() {
    assert_eq!(
        ::core::mem::size_of::<arm_cfft_radix2_instance_q31>(),
        32usize,
        concat!("Size of: ", stringify!(arm_cfft_radix2_instance_q31))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_cfft_radix2_instance_q31>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_cfft_radix2_instance_q31))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix2_instance_q31>())).fftLen as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix2_instance_q31),
            "::",
            stringify!(fftLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix2_instance_q31>())).ifftFlag as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix2_instance_q31),
            "::",
            stringify!(ifftFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix2_instance_q31>())).bitReverseFlag as *const _
                as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix2_instance_q31),
            "::",
            stringify!(bitReverseFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix2_instance_q31>())).pTwiddle as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix2_instance_q31),
            "::",
            stringify!(pTwiddle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix2_instance_q31>())).pBitRevTable as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix2_instance_q31),
            "::",
            stringify!(pBitRevTable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix2_instance_q31>())).twidCoefModifier as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix2_instance_q31),
            "::",
            stringify!(twidCoefModifier)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix2_instance_q31>())).bitRevFactor as *const _
                as usize
        },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix2_instance_q31),
            "::",
            stringify!(bitRevFactor)
        )
    );
}
extern "C" {
    pub fn arm_cfft_radix2_init_q31(
        S: *mut arm_cfft_radix2_instance_q31,
        fftLen: u16,
        ifftFlag: u8,
        bitReverseFlag: u8,
    ) -> arm_status::Type;
}
extern "C" {
    pub fn arm_cfft_radix2_q31(S: *const arm_cfft_radix2_instance_q31, pSrc: *mut q31_t);
}
#[doc = " @brief Instance structure for the Q31 CFFT/CIFFT function."]
#[repr(C)]
pub struct arm_cfft_radix4_instance_q31 {
    #[doc = "< length of the FFT."]
    pub fftLen: u16,
    #[doc = "< flag that selects forward (ifftFlag=0) or inverse (ifftFlag=1) transform."]
    pub ifftFlag: u8,
    #[doc = "< flag that enables (bitReverseFlag=1) or disables (bitReverseFlag=0) bit reversal of output."]
    pub bitReverseFlag: u8,
    #[doc = "< points to the twiddle factor table."]
    pub pTwiddle: *const q31_t,
    #[doc = "< points to the bit reversal table."]
    pub pBitRevTable: *const u16,
    #[doc = "< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table."]
    pub twidCoefModifier: u16,
    #[doc = "< bit reversal modifier that supports different size FFTs with the same bit reversal table."]
    pub bitRevFactor: u16,
}
#[test]
fn bindgen_test_layout_arm_cfft_radix4_instance_q31() {
    assert_eq!(
        ::core::mem::size_of::<arm_cfft_radix4_instance_q31>(),
        32usize,
        concat!("Size of: ", stringify!(arm_cfft_radix4_instance_q31))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_cfft_radix4_instance_q31>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_cfft_radix4_instance_q31))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix4_instance_q31>())).fftLen as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix4_instance_q31),
            "::",
            stringify!(fftLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix4_instance_q31>())).ifftFlag as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix4_instance_q31),
            "::",
            stringify!(ifftFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix4_instance_q31>())).bitReverseFlag as *const _
                as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix4_instance_q31),
            "::",
            stringify!(bitReverseFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix4_instance_q31>())).pTwiddle as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix4_instance_q31),
            "::",
            stringify!(pTwiddle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix4_instance_q31>())).pBitRevTable as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix4_instance_q31),
            "::",
            stringify!(pBitRevTable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix4_instance_q31>())).twidCoefModifier as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix4_instance_q31),
            "::",
            stringify!(twidCoefModifier)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix4_instance_q31>())).bitRevFactor as *const _
                as usize
        },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix4_instance_q31),
            "::",
            stringify!(bitRevFactor)
        )
    );
}
extern "C" {
    pub fn arm_cfft_radix4_q31(S: *const arm_cfft_radix4_instance_q31, pSrc: *mut q31_t);
}
extern "C" {
    pub fn arm_cfft_radix4_init_q31(
        S: *mut arm_cfft_radix4_instance_q31,
        fftLen: u16,
        ifftFlag: u8,
        bitReverseFlag: u8,
    ) -> arm_status::Type;
}
#[doc = " @brief Instance structure for the floating-point CFFT/CIFFT function."]
#[repr(C)]
pub struct arm_cfft_radix2_instance_f32 {
    #[doc = "< length of the FFT."]
    pub fftLen: u16,
    #[doc = "< flag that selects forward (ifftFlag=0) or inverse (ifftFlag=1) transform."]
    pub ifftFlag: u8,
    #[doc = "< flag that enables (bitReverseFlag=1) or disables (bitReverseFlag=0) bit reversal of output."]
    pub bitReverseFlag: u8,
    #[doc = "< points to the Twiddle factor table."]
    pub pTwiddle: *const float32_t,
    #[doc = "< points to the bit reversal table."]
    pub pBitRevTable: *const u16,
    #[doc = "< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table."]
    pub twidCoefModifier: u16,
    #[doc = "< bit reversal modifier that supports different size FFTs with the same bit reversal table."]
    pub bitRevFactor: u16,
    #[doc = "< value of 1/fftLen."]
    pub onebyfftLen: float32_t,
}
#[test]
fn bindgen_test_layout_arm_cfft_radix2_instance_f32() {
    assert_eq!(
        ::core::mem::size_of::<arm_cfft_radix2_instance_f32>(),
        32usize,
        concat!("Size of: ", stringify!(arm_cfft_radix2_instance_f32))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_cfft_radix2_instance_f32>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_cfft_radix2_instance_f32))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix2_instance_f32>())).fftLen as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix2_instance_f32),
            "::",
            stringify!(fftLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix2_instance_f32>())).ifftFlag as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix2_instance_f32),
            "::",
            stringify!(ifftFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix2_instance_f32>())).bitReverseFlag as *const _
                as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix2_instance_f32),
            "::",
            stringify!(bitReverseFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix2_instance_f32>())).pTwiddle as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix2_instance_f32),
            "::",
            stringify!(pTwiddle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix2_instance_f32>())).pBitRevTable as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix2_instance_f32),
            "::",
            stringify!(pBitRevTable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix2_instance_f32>())).twidCoefModifier as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix2_instance_f32),
            "::",
            stringify!(twidCoefModifier)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix2_instance_f32>())).bitRevFactor as *const _
                as usize
        },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix2_instance_f32),
            "::",
            stringify!(bitRevFactor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix2_instance_f32>())).onebyfftLen as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix2_instance_f32),
            "::",
            stringify!(onebyfftLen)
        )
    );
}
extern "C" {
    pub fn arm_cfft_radix2_init_f32(
        S: *mut arm_cfft_radix2_instance_f32,
        fftLen: u16,
        ifftFlag: u8,
        bitReverseFlag: u8,
    ) -> arm_status::Type;
}
extern "C" {
    pub fn arm_cfft_radix2_f32(S: *const arm_cfft_radix2_instance_f32, pSrc: *mut float32_t);
}
#[doc = " @brief Instance structure for the floating-point CFFT/CIFFT function."]
#[repr(C)]
pub struct arm_cfft_radix4_instance_f32 {
    #[doc = "< length of the FFT."]
    pub fftLen: u16,
    #[doc = "< flag that selects forward (ifftFlag=0) or inverse (ifftFlag=1) transform."]
    pub ifftFlag: u8,
    #[doc = "< flag that enables (bitReverseFlag=1) or disables (bitReverseFlag=0) bit reversal of output."]
    pub bitReverseFlag: u8,
    #[doc = "< points to the Twiddle factor table."]
    pub pTwiddle: *const float32_t,
    #[doc = "< points to the bit reversal table."]
    pub pBitRevTable: *const u16,
    #[doc = "< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table."]
    pub twidCoefModifier: u16,
    #[doc = "< bit reversal modifier that supports different size FFTs with the same bit reversal table."]
    pub bitRevFactor: u16,
    #[doc = "< value of 1/fftLen."]
    pub onebyfftLen: float32_t,
}
#[test]
fn bindgen_test_layout_arm_cfft_radix4_instance_f32() {
    assert_eq!(
        ::core::mem::size_of::<arm_cfft_radix4_instance_f32>(),
        32usize,
        concat!("Size of: ", stringify!(arm_cfft_radix4_instance_f32))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_cfft_radix4_instance_f32>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_cfft_radix4_instance_f32))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix4_instance_f32>())).fftLen as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix4_instance_f32),
            "::",
            stringify!(fftLen)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix4_instance_f32>())).ifftFlag as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix4_instance_f32),
            "::",
            stringify!(ifftFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix4_instance_f32>())).bitReverseFlag as *const _
                as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix4_instance_f32),
            "::",
            stringify!(bitReverseFlag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix4_instance_f32>())).pTwiddle as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix4_instance_f32),
            "::",
            stringify!(pTwiddle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix4_instance_f32>())).pBitRevTable as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix4_instance_f32),
            "::",
            stringify!(pBitRevTable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix4_instance_f32>())).twidCoefModifier as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix4_instance_f32),
            "::",
            stringify!(twidCoefModifier)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix4_instance_f32>())).bitRevFactor as *const _
                as usize
        },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix4_instance_f32),
            "::",
            stringify!(bitRevFactor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_radix4_instance_f32>())).onebyfftLen as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_radix4_instance_f32),
            "::",
            stringify!(onebyfftLen)
        )
    );
}
extern "C" {
    pub fn arm_cfft_radix4_init_f32(
        S: *mut arm_cfft_radix4_instance_f32,
        fftLen: u16,
        ifftFlag: u8,
        bitReverseFlag: u8,
    ) -> arm_status::Type;
}
extern "C" {
    pub fn arm_cfft_radix4_f32(S: *const arm_cfft_radix4_instance_f32, pSrc: *mut float32_t);
}
#[doc = " @brief Instance structure for the fixed-point CFFT/CIFFT function."]
#[repr(C)]
pub struct arm_cfft_instance_q15 {
    #[doc = "< length of the FFT."]
    pub fftLen: u16,
    #[doc = "< points to the Twiddle factor table."]
    pub pTwiddle: *const q15_t,
    #[doc = "< points to the bit reversal table."]
    pub pBitRevTable: *const u16,
    #[doc = "< bit reversal table length."]
    pub bitRevLength: u16,
}
#[test]
fn bindgen_test_layout_arm_cfft_instance_q15() {
    assert_eq!(
        ::core::mem::size_of::<arm_cfft_instance_q15>(),
        32usize,
        concat!("Size of: ", stringify!(arm_cfft_instance_q15))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_cfft_instance_q15>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_cfft_instance_q15))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_cfft_instance_q15>())).fftLen as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_instance_q15),
            "::",
            stringify!(fftLen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_cfft_instance_q15>())).pTwiddle as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_instance_q15),
            "::",
            stringify!(pTwiddle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_instance_q15>())).pBitRevTable as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_instance_q15),
            "::",
            stringify!(pBitRevTable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_instance_q15>())).bitRevLength as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_instance_q15),
            "::",
            stringify!(bitRevLength)
        )
    );
}
extern "C" {
    pub fn arm_cfft_q15(
        S: *const arm_cfft_instance_q15,
        p1: *mut q15_t,
        ifftFlag: u8,
        bitReverseFlag: u8,
    );
}
#[doc = " @brief Instance structure for the fixed-point CFFT/CIFFT function."]
#[repr(C)]
pub struct arm_cfft_instance_q31 {
    #[doc = "< length of the FFT."]
    pub fftLen: u16,
    #[doc = "< points to the Twiddle factor table."]
    pub pTwiddle: *const q31_t,
    #[doc = "< points to the bit reversal table."]
    pub pBitRevTable: *const u16,
    #[doc = "< bit reversal table length."]
    pub bitRevLength: u16,
}
#[test]
fn bindgen_test_layout_arm_cfft_instance_q31() {
    assert_eq!(
        ::core::mem::size_of::<arm_cfft_instance_q31>(),
        32usize,
        concat!("Size of: ", stringify!(arm_cfft_instance_q31))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_cfft_instance_q31>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_cfft_instance_q31))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_cfft_instance_q31>())).fftLen as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_instance_q31),
            "::",
            stringify!(fftLen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_cfft_instance_q31>())).pTwiddle as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_instance_q31),
            "::",
            stringify!(pTwiddle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_instance_q31>())).pBitRevTable as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_instance_q31),
            "::",
            stringify!(pBitRevTable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_instance_q31>())).bitRevLength as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_instance_q31),
            "::",
            stringify!(bitRevLength)
        )
    );
}
extern "C" {
    pub fn arm_cfft_q31(
        S: *const arm_cfft_instance_q31,
        p1: *mut q31_t,
        ifftFlag: u8,
        bitReverseFlag: u8,
    );
}
#[doc = " @brief Instance structure for the floating-point CFFT/CIFFT function."]
#[repr(C)]
pub struct arm_cfft_instance_f32 {
    #[doc = "< length of the FFT."]
    pub fftLen: u16,
    #[doc = "< points to the Twiddle factor table."]
    pub pTwiddle: *const float32_t,
    #[doc = "< points to the bit reversal table."]
    pub pBitRevTable: *const u16,
    #[doc = "< bit reversal table length."]
    pub bitRevLength: u16,
}
#[test]
fn bindgen_test_layout_arm_cfft_instance_f32() {
    assert_eq!(
        ::core::mem::size_of::<arm_cfft_instance_f32>(),
        32usize,
        concat!("Size of: ", stringify!(arm_cfft_instance_f32))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_cfft_instance_f32>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_cfft_instance_f32))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_cfft_instance_f32>())).fftLen as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_instance_f32),
            "::",
            stringify!(fftLen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_cfft_instance_f32>())).pTwiddle as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_instance_f32),
            "::",
            stringify!(pTwiddle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_instance_f32>())).pBitRevTable as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_instance_f32),
            "::",
            stringify!(pBitRevTable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_cfft_instance_f32>())).bitRevLength as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_cfft_instance_f32),
            "::",
            stringify!(bitRevLength)
        )
    );
}
extern "C" {
    pub fn arm_cfft_f32(
        S: *const arm_cfft_instance_f32,
        p1: *mut float32_t,
        ifftFlag: u8,
        bitReverseFlag: u8,
    );
}
#[doc = " @brief Instance structure for the Q15 RFFT/RIFFT function."]
#[repr(C)]
pub struct arm_rfft_instance_q15 {
    #[doc = "< length of the real FFT."]
    pub fftLenReal: u32,
    #[doc = "< flag that selects forward (ifftFlagR=0) or inverse (ifftFlagR=1) transform."]
    pub ifftFlagR: u8,
    #[doc = "< flag that enables (bitReverseFlagR=1) or disables (bitReverseFlagR=0) bit reversal of output."]
    pub bitReverseFlagR: u8,
    #[doc = "< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table."]
    pub twidCoefRModifier: u32,
    #[doc = "< points to the real twiddle factor table."]
    pub pTwiddleAReal: *const q15_t,
    #[doc = "< points to the imag twiddle factor table."]
    pub pTwiddleBReal: *const q15_t,
    #[doc = "< points to the complex FFT instance."]
    pub pCfft: *const arm_cfft_instance_q15,
}
#[test]
fn bindgen_test_layout_arm_rfft_instance_q15() {
    assert_eq!(
        ::core::mem::size_of::<arm_rfft_instance_q15>(),
        40usize,
        concat!("Size of: ", stringify!(arm_rfft_instance_q15))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_rfft_instance_q15>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_rfft_instance_q15))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_rfft_instance_q15>())).fftLenReal as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_rfft_instance_q15),
            "::",
            stringify!(fftLenReal)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_rfft_instance_q15>())).ifftFlagR as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_rfft_instance_q15),
            "::",
            stringify!(ifftFlagR)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_rfft_instance_q15>())).bitReverseFlagR as *const _ as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_rfft_instance_q15),
            "::",
            stringify!(bitReverseFlagR)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_rfft_instance_q15>())).twidCoefRModifier as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_rfft_instance_q15),
            "::",
            stringify!(twidCoefRModifier)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_rfft_instance_q15>())).pTwiddleAReal as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_rfft_instance_q15),
            "::",
            stringify!(pTwiddleAReal)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_rfft_instance_q15>())).pTwiddleBReal as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_rfft_instance_q15),
            "::",
            stringify!(pTwiddleBReal)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_rfft_instance_q15>())).pCfft as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_rfft_instance_q15),
            "::",
            stringify!(pCfft)
        )
    );
}
extern "C" {
    pub fn arm_rfft_init_q15(
        S: *mut arm_rfft_instance_q15,
        fftLenReal: u32,
        ifftFlagR: u32,
        bitReverseFlag: u32,
    ) -> arm_status::Type;
}
extern "C" {
    pub fn arm_rfft_q15(S: *const arm_rfft_instance_q15, pSrc: *mut q15_t, pDst: *mut q15_t);
}
#[doc = " @brief Instance structure for the Q31 RFFT/RIFFT function."]
#[repr(C)]
pub struct arm_rfft_instance_q31 {
    #[doc = "< length of the real FFT."]
    pub fftLenReal: u32,
    #[doc = "< flag that selects forward (ifftFlagR=0) or inverse (ifftFlagR=1) transform."]
    pub ifftFlagR: u8,
    #[doc = "< flag that enables (bitReverseFlagR=1) or disables (bitReverseFlagR=0) bit reversal of output."]
    pub bitReverseFlagR: u8,
    #[doc = "< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table."]
    pub twidCoefRModifier: u32,
    #[doc = "< points to the real twiddle factor table."]
    pub pTwiddleAReal: *const q31_t,
    #[doc = "< points to the imag twiddle factor table."]
    pub pTwiddleBReal: *const q31_t,
    #[doc = "< points to the complex FFT instance."]
    pub pCfft: *const arm_cfft_instance_q31,
}
#[test]
fn bindgen_test_layout_arm_rfft_instance_q31() {
    assert_eq!(
        ::core::mem::size_of::<arm_rfft_instance_q31>(),
        40usize,
        concat!("Size of: ", stringify!(arm_rfft_instance_q31))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_rfft_instance_q31>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_rfft_instance_q31))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_rfft_instance_q31>())).fftLenReal as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_rfft_instance_q31),
            "::",
            stringify!(fftLenReal)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_rfft_instance_q31>())).ifftFlagR as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_rfft_instance_q31),
            "::",
            stringify!(ifftFlagR)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_rfft_instance_q31>())).bitReverseFlagR as *const _ as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_rfft_instance_q31),
            "::",
            stringify!(bitReverseFlagR)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_rfft_instance_q31>())).twidCoefRModifier as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_rfft_instance_q31),
            "::",
            stringify!(twidCoefRModifier)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_rfft_instance_q31>())).pTwiddleAReal as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_rfft_instance_q31),
            "::",
            stringify!(pTwiddleAReal)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_rfft_instance_q31>())).pTwiddleBReal as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_rfft_instance_q31),
            "::",
            stringify!(pTwiddleBReal)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_rfft_instance_q31>())).pCfft as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_rfft_instance_q31),
            "::",
            stringify!(pCfft)
        )
    );
}
extern "C" {
    pub fn arm_rfft_init_q31(
        S: *mut arm_rfft_instance_q31,
        fftLenReal: u32,
        ifftFlagR: u32,
        bitReverseFlag: u32,
    ) -> arm_status::Type;
}
extern "C" {
    pub fn arm_rfft_q31(S: *const arm_rfft_instance_q31, pSrc: *mut q31_t, pDst: *mut q31_t);
}
#[doc = " @brief Instance structure for the floating-point RFFT/RIFFT function."]
#[repr(C)]
pub struct arm_rfft_instance_f32 {
    #[doc = "< length of the real FFT."]
    pub fftLenReal: u32,
    #[doc = "< length of the complex FFT."]
    pub fftLenBy2: u16,
    #[doc = "< flag that selects forward (ifftFlagR=0) or inverse (ifftFlagR=1) transform."]
    pub ifftFlagR: u8,
    #[doc = "< flag that enables (bitReverseFlagR=1) or disables (bitReverseFlagR=0) bit reversal of output."]
    pub bitReverseFlagR: u8,
    #[doc = "< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table."]
    pub twidCoefRModifier: u32,
    #[doc = "< points to the real twiddle factor table."]
    pub pTwiddleAReal: *const float32_t,
    #[doc = "< points to the imag twiddle factor table."]
    pub pTwiddleBReal: *const float32_t,
    #[doc = "< points to the complex FFT instance."]
    pub pCfft: *mut arm_cfft_radix4_instance_f32,
}
#[test]
fn bindgen_test_layout_arm_rfft_instance_f32() {
    assert_eq!(
        ::core::mem::size_of::<arm_rfft_instance_f32>(),
        40usize,
        concat!("Size of: ", stringify!(arm_rfft_instance_f32))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_rfft_instance_f32>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_rfft_instance_f32))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_rfft_instance_f32>())).fftLenReal as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_rfft_instance_f32),
            "::",
            stringify!(fftLenReal)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_rfft_instance_f32>())).fftLenBy2 as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_rfft_instance_f32),
            "::",
            stringify!(fftLenBy2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_rfft_instance_f32>())).ifftFlagR as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_rfft_instance_f32),
            "::",
            stringify!(ifftFlagR)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_rfft_instance_f32>())).bitReverseFlagR as *const _ as usize
        },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_rfft_instance_f32),
            "::",
            stringify!(bitReverseFlagR)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_rfft_instance_f32>())).twidCoefRModifier as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_rfft_instance_f32),
            "::",
            stringify!(twidCoefRModifier)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_rfft_instance_f32>())).pTwiddleAReal as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_rfft_instance_f32),
            "::",
            stringify!(pTwiddleAReal)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_rfft_instance_f32>())).pTwiddleBReal as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_rfft_instance_f32),
            "::",
            stringify!(pTwiddleBReal)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_rfft_instance_f32>())).pCfft as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_rfft_instance_f32),
            "::",
            stringify!(pCfft)
        )
    );
}
extern "C" {
    pub fn arm_rfft_init_f32(
        S: *mut arm_rfft_instance_f32,
        S_CFFT: *mut arm_cfft_radix4_instance_f32,
        fftLenReal: u32,
        ifftFlagR: u32,
        bitReverseFlag: u32,
    ) -> arm_status::Type;
}
extern "C" {
    pub fn arm_rfft_f32(
        S: *const arm_rfft_instance_f32,
        pSrc: *mut float32_t,
        pDst: *mut float32_t,
    );
}
#[doc = " @brief Instance structure for the floating-point RFFT/RIFFT function."]
#[repr(C)]
pub struct arm_rfft_fast_instance_f32 {
    #[doc = "< Internal CFFT structure."]
    pub Sint: arm_cfft_instance_f32,
    #[doc = "< length of the real sequence"]
    pub fftLenRFFT: u16,
    #[doc = "< Twiddle factors real stage"]
    pub pTwiddleRFFT: *const float32_t,
}
#[test]
fn bindgen_test_layout_arm_rfft_fast_instance_f32() {
    assert_eq!(
        ::core::mem::size_of::<arm_rfft_fast_instance_f32>(),
        48usize,
        concat!("Size of: ", stringify!(arm_rfft_fast_instance_f32))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_rfft_fast_instance_f32>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_rfft_fast_instance_f32))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_rfft_fast_instance_f32>())).Sint as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_rfft_fast_instance_f32),
            "::",
            stringify!(Sint)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_rfft_fast_instance_f32>())).fftLenRFFT as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_rfft_fast_instance_f32),
            "::",
            stringify!(fftLenRFFT)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_rfft_fast_instance_f32>())).pTwiddleRFFT as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_rfft_fast_instance_f32),
            "::",
            stringify!(pTwiddleRFFT)
        )
    );
}
extern "C" {
    pub fn arm_rfft_fast_init_f32(
        S: *mut arm_rfft_fast_instance_f32,
        fftLen: u16,
    ) -> arm_status::Type;
}
extern "C" {
    pub fn arm_rfft_32_fast_init_f32(S: *mut arm_rfft_fast_instance_f32) -> arm_status::Type;
}
extern "C" {
    pub fn arm_rfft_64_fast_init_f32(S: *mut arm_rfft_fast_instance_f32) -> arm_status::Type;
}
extern "C" {
    pub fn arm_rfft_128_fast_init_f32(S: *mut arm_rfft_fast_instance_f32) -> arm_status::Type;
}
extern "C" {
    pub fn arm_rfft_256_fast_init_f32(S: *mut arm_rfft_fast_instance_f32) -> arm_status::Type;
}
extern "C" {
    pub fn arm_rfft_512_fast_init_f32(S: *mut arm_rfft_fast_instance_f32) -> arm_status::Type;
}
extern "C" {
    pub fn arm_rfft_1024_fast_init_f32(S: *mut arm_rfft_fast_instance_f32) -> arm_status::Type;
}
extern "C" {
    pub fn arm_rfft_2048_fast_init_f32(S: *mut arm_rfft_fast_instance_f32) -> arm_status::Type;
}
extern "C" {
    pub fn arm_rfft_4096_fast_init_f32(S: *mut arm_rfft_fast_instance_f32) -> arm_status::Type;
}
extern "C" {
    pub fn arm_rfft_fast_f32(
        S: *mut arm_rfft_fast_instance_f32,
        p: *mut float32_t,
        pOut: *mut float32_t,
        ifftFlag: u8,
    );
}
#[doc = " @brief Instance structure for the floating-point DCT4/IDCT4 function."]
#[repr(C)]
pub struct arm_dct4_instance_f32 {
    #[doc = "< length of the DCT4."]
    pub N: u16,
    #[doc = "< half of the length of the DCT4."]
    pub Nby2: u16,
    #[doc = "< normalizing factor."]
    pub normalize: float32_t,
    #[doc = "< points to the twiddle factor table."]
    pub pTwiddle: *const float32_t,
    #[doc = "< points to the cosFactor table."]
    pub pCosFactor: *const float32_t,
    #[doc = "< points to the real FFT instance."]
    pub pRfft: *mut arm_rfft_instance_f32,
    #[doc = "< points to the complex FFT instance."]
    pub pCfft: *mut arm_cfft_radix4_instance_f32,
}
#[test]
fn bindgen_test_layout_arm_dct4_instance_f32() {
    assert_eq!(
        ::core::mem::size_of::<arm_dct4_instance_f32>(),
        40usize,
        concat!("Size of: ", stringify!(arm_dct4_instance_f32))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_dct4_instance_f32>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_dct4_instance_f32))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_dct4_instance_f32>())).N as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_dct4_instance_f32),
            "::",
            stringify!(N)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_dct4_instance_f32>())).Nby2 as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_dct4_instance_f32),
            "::",
            stringify!(Nby2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_dct4_instance_f32>())).normalize as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_dct4_instance_f32),
            "::",
            stringify!(normalize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_dct4_instance_f32>())).pTwiddle as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_dct4_instance_f32),
            "::",
            stringify!(pTwiddle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_dct4_instance_f32>())).pCosFactor as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_dct4_instance_f32),
            "::",
            stringify!(pCosFactor)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_dct4_instance_f32>())).pRfft as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_dct4_instance_f32),
            "::",
            stringify!(pRfft)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_dct4_instance_f32>())).pCfft as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_dct4_instance_f32),
            "::",
            stringify!(pCfft)
        )
    );
}
extern "C" {
    #[doc = " @brief  Initialization function for the floating-point DCT4/IDCT4."]
    #[doc = " @param[in,out] S          points to an instance of floating-point DCT4/IDCT4 structure."]
    #[doc = " @param[in]     S_RFFT     points to an instance of floating-point RFFT/RIFFT structure."]
    #[doc = " @param[in]     S_CFFT     points to an instance of floating-point CFFT/CIFFT structure."]
    #[doc = " @param[in]     N          length of the DCT4."]
    #[doc = " @param[in]     Nby2       half of the length of the DCT4."]
    #[doc = " @param[in]     normalize  normalizing factor."]
    #[doc = " @return      arm_status function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_ARGUMENT_ERROR if <code>fftLenReal</code> is not a supported transform length."]
    pub fn arm_dct4_init_f32(
        S: *mut arm_dct4_instance_f32,
        S_RFFT: *mut arm_rfft_instance_f32,
        S_CFFT: *mut arm_cfft_radix4_instance_f32,
        N: u16,
        Nby2: u16,
        normalize: float32_t,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Processing function for the floating-point DCT4/IDCT4."]
    #[doc = " @param[in]     S              points to an instance of the floating-point DCT4/IDCT4 structure."]
    #[doc = " @param[in]     pState         points to state buffer."]
    #[doc = " @param[in,out] pInlineBuffer  points to the in-place input and output buffer."]
    pub fn arm_dct4_f32(
        S: *const arm_dct4_instance_f32,
        pState: *mut float32_t,
        pInlineBuffer: *mut float32_t,
    );
}
#[doc = " @brief Instance structure for the Q31 DCT4/IDCT4 function."]
#[repr(C)]
pub struct arm_dct4_instance_q31 {
    #[doc = "< length of the DCT4."]
    pub N: u16,
    #[doc = "< half of the length of the DCT4."]
    pub Nby2: u16,
    #[doc = "< normalizing factor."]
    pub normalize: q31_t,
    #[doc = "< points to the twiddle factor table."]
    pub pTwiddle: *const q31_t,
    #[doc = "< points to the cosFactor table."]
    pub pCosFactor: *const q31_t,
    #[doc = "< points to the real FFT instance."]
    pub pRfft: *mut arm_rfft_instance_q31,
    #[doc = "< points to the complex FFT instance."]
    pub pCfft: *mut arm_cfft_radix4_instance_q31,
}
#[test]
fn bindgen_test_layout_arm_dct4_instance_q31() {
    assert_eq!(
        ::core::mem::size_of::<arm_dct4_instance_q31>(),
        40usize,
        concat!("Size of: ", stringify!(arm_dct4_instance_q31))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_dct4_instance_q31>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_dct4_instance_q31))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_dct4_instance_q31>())).N as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_dct4_instance_q31),
            "::",
            stringify!(N)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_dct4_instance_q31>())).Nby2 as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_dct4_instance_q31),
            "::",
            stringify!(Nby2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_dct4_instance_q31>())).normalize as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_dct4_instance_q31),
            "::",
            stringify!(normalize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_dct4_instance_q31>())).pTwiddle as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_dct4_instance_q31),
            "::",
            stringify!(pTwiddle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_dct4_instance_q31>())).pCosFactor as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_dct4_instance_q31),
            "::",
            stringify!(pCosFactor)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_dct4_instance_q31>())).pRfft as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_dct4_instance_q31),
            "::",
            stringify!(pRfft)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_dct4_instance_q31>())).pCfft as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_dct4_instance_q31),
            "::",
            stringify!(pCfft)
        )
    );
}
extern "C" {
    #[doc = " @brief  Initialization function for the Q31 DCT4/IDCT4."]
    #[doc = " @param[in,out] S          points to an instance of Q31 DCT4/IDCT4 structure."]
    #[doc = " @param[in]     S_RFFT     points to an instance of Q31 RFFT/RIFFT structure"]
    #[doc = " @param[in]     S_CFFT     points to an instance of Q31 CFFT/CIFFT structure"]
    #[doc = " @param[in]     N          length of the DCT4."]
    #[doc = " @param[in]     Nby2       half of the length of the DCT4."]
    #[doc = " @param[in]     normalize  normalizing factor."]
    #[doc = " @return      arm_status function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_ARGUMENT_ERROR if <code>N</code> is not a supported transform length."]
    pub fn arm_dct4_init_q31(
        S: *mut arm_dct4_instance_q31,
        S_RFFT: *mut arm_rfft_instance_q31,
        S_CFFT: *mut arm_cfft_radix4_instance_q31,
        N: u16,
        Nby2: u16,
        normalize: q31_t,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Processing function for the Q31 DCT4/IDCT4."]
    #[doc = " @param[in]     S              points to an instance of the Q31 DCT4 structure."]
    #[doc = " @param[in]     pState         points to state buffer."]
    #[doc = " @param[in,out] pInlineBuffer  points to the in-place input and output buffer."]
    pub fn arm_dct4_q31(
        S: *const arm_dct4_instance_q31,
        pState: *mut q31_t,
        pInlineBuffer: *mut q31_t,
    );
}
#[doc = " @brief Instance structure for the Q15 DCT4/IDCT4 function."]
#[repr(C)]
pub struct arm_dct4_instance_q15 {
    #[doc = "< length of the DCT4."]
    pub N: u16,
    #[doc = "< half of the length of the DCT4."]
    pub Nby2: u16,
    #[doc = "< normalizing factor."]
    pub normalize: q15_t,
    #[doc = "< points to the twiddle factor table."]
    pub pTwiddle: *const q15_t,
    #[doc = "< points to the cosFactor table."]
    pub pCosFactor: *const q15_t,
    #[doc = "< points to the real FFT instance."]
    pub pRfft: *mut arm_rfft_instance_q15,
    #[doc = "< points to the complex FFT instance."]
    pub pCfft: *mut arm_cfft_radix4_instance_q15,
}
#[test]
fn bindgen_test_layout_arm_dct4_instance_q15() {
    assert_eq!(
        ::core::mem::size_of::<arm_dct4_instance_q15>(),
        40usize,
        concat!("Size of: ", stringify!(arm_dct4_instance_q15))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_dct4_instance_q15>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_dct4_instance_q15))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_dct4_instance_q15>())).N as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_dct4_instance_q15),
            "::",
            stringify!(N)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_dct4_instance_q15>())).Nby2 as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_dct4_instance_q15),
            "::",
            stringify!(Nby2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_dct4_instance_q15>())).normalize as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_dct4_instance_q15),
            "::",
            stringify!(normalize)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_dct4_instance_q15>())).pTwiddle as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_dct4_instance_q15),
            "::",
            stringify!(pTwiddle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_dct4_instance_q15>())).pCosFactor as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_dct4_instance_q15),
            "::",
            stringify!(pCosFactor)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_dct4_instance_q15>())).pRfft as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_dct4_instance_q15),
            "::",
            stringify!(pRfft)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_dct4_instance_q15>())).pCfft as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_dct4_instance_q15),
            "::",
            stringify!(pCfft)
        )
    );
}
extern "C" {
    #[doc = " @brief  Initialization function for the Q15 DCT4/IDCT4."]
    #[doc = " @param[in,out] S          points to an instance of Q15 DCT4/IDCT4 structure."]
    #[doc = " @param[in]     S_RFFT     points to an instance of Q15 RFFT/RIFFT structure."]
    #[doc = " @param[in]     S_CFFT     points to an instance of Q15 CFFT/CIFFT structure."]
    #[doc = " @param[in]     N          length of the DCT4."]
    #[doc = " @param[in]     Nby2       half of the length of the DCT4."]
    #[doc = " @param[in]     normalize  normalizing factor."]
    #[doc = " @return      arm_status function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_ARGUMENT_ERROR if <code>N</code> is not a supported transform length."]
    pub fn arm_dct4_init_q15(
        S: *mut arm_dct4_instance_q15,
        S_RFFT: *mut arm_rfft_instance_q15,
        S_CFFT: *mut arm_cfft_radix4_instance_q15,
        N: u16,
        Nby2: u16,
        normalize: q15_t,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Processing function for the Q15 DCT4/IDCT4."]
    #[doc = " @param[in]     S              points to an instance of the Q15 DCT4 structure."]
    #[doc = " @param[in]     pState         points to state buffer."]
    #[doc = " @param[in,out] pInlineBuffer  points to the in-place input and output buffer."]
    pub fn arm_dct4_q15(
        S: *const arm_dct4_instance_q15,
        pState: *mut q15_t,
        pInlineBuffer: *mut q15_t,
    );
}
extern "C" {
    #[doc = " @brief Floating-point vector addition."]
    #[doc = " @param[in]  pSrcA      points to the first input vector"]
    #[doc = " @param[in]  pSrcB      points to the second input vector"]
    #[doc = " @param[out] pDst       points to the output vector"]
    #[doc = " @param[in]  blockSize  number of samples in each vector"]
    pub fn arm_add_f32(
        pSrcA: *const float32_t,
        pSrcB: *const float32_t,
        pDst: *mut float32_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Q7 vector addition."]
    #[doc = " @param[in]  pSrcA      points to the first input vector"]
    #[doc = " @param[in]  pSrcB      points to the second input vector"]
    #[doc = " @param[out] pDst       points to the output vector"]
    #[doc = " @param[in]  blockSize  number of samples in each vector"]
    pub fn arm_add_q7(pSrcA: *const q7_t, pSrcB: *const q7_t, pDst: *mut q7_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief Q15 vector addition."]
    #[doc = " @param[in]  pSrcA      points to the first input vector"]
    #[doc = " @param[in]  pSrcB      points to the second input vector"]
    #[doc = " @param[out] pDst       points to the output vector"]
    #[doc = " @param[in]  blockSize  number of samples in each vector"]
    pub fn arm_add_q15(pSrcA: *const q15_t, pSrcB: *const q15_t, pDst: *mut q15_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief Q31 vector addition."]
    #[doc = " @param[in]  pSrcA      points to the first input vector"]
    #[doc = " @param[in]  pSrcB      points to the second input vector"]
    #[doc = " @param[out] pDst       points to the output vector"]
    #[doc = " @param[in]  blockSize  number of samples in each vector"]
    pub fn arm_add_q31(pSrcA: *const q31_t, pSrcB: *const q31_t, pDst: *mut q31_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief Floating-point vector subtraction."]
    #[doc = " @param[in]  pSrcA      points to the first input vector"]
    #[doc = " @param[in]  pSrcB      points to the second input vector"]
    #[doc = " @param[out] pDst       points to the output vector"]
    #[doc = " @param[in]  blockSize  number of samples in each vector"]
    pub fn arm_sub_f32(
        pSrcA: *const float32_t,
        pSrcB: *const float32_t,
        pDst: *mut float32_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Q7 vector subtraction."]
    #[doc = " @param[in]  pSrcA      points to the first input vector"]
    #[doc = " @param[in]  pSrcB      points to the second input vector"]
    #[doc = " @param[out] pDst       points to the output vector"]
    #[doc = " @param[in]  blockSize  number of samples in each vector"]
    pub fn arm_sub_q7(pSrcA: *const q7_t, pSrcB: *const q7_t, pDst: *mut q7_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief Q15 vector subtraction."]
    #[doc = " @param[in]  pSrcA      points to the first input vector"]
    #[doc = " @param[in]  pSrcB      points to the second input vector"]
    #[doc = " @param[out] pDst       points to the output vector"]
    #[doc = " @param[in]  blockSize  number of samples in each vector"]
    pub fn arm_sub_q15(pSrcA: *const q15_t, pSrcB: *const q15_t, pDst: *mut q15_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief Q31 vector subtraction."]
    #[doc = " @param[in]  pSrcA      points to the first input vector"]
    #[doc = " @param[in]  pSrcB      points to the second input vector"]
    #[doc = " @param[out] pDst       points to the output vector"]
    #[doc = " @param[in]  blockSize  number of samples in each vector"]
    pub fn arm_sub_q31(pSrcA: *const q31_t, pSrcB: *const q31_t, pDst: *mut q31_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief Multiplies a floating-point vector by a scalar."]
    #[doc = " @param[in]  pSrc       points to the input vector"]
    #[doc = " @param[in]  scale      scale factor to be applied"]
    #[doc = " @param[out] pDst       points to the output vector"]
    #[doc = " @param[in]  blockSize  number of samples in the vector"]
    pub fn arm_scale_f32(
        pSrc: *const float32_t,
        scale: float32_t,
        pDst: *mut float32_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Multiplies a Q7 vector by a scalar."]
    #[doc = " @param[in]  pSrc        points to the input vector"]
    #[doc = " @param[in]  scaleFract  fractional portion of the scale value"]
    #[doc = " @param[in]  shift       number of bits to shift the result by"]
    #[doc = " @param[out] pDst        points to the output vector"]
    #[doc = " @param[in]  blockSize   number of samples in the vector"]
    pub fn arm_scale_q7(
        pSrc: *const q7_t,
        scaleFract: q7_t,
        shift: i8,
        pDst: *mut q7_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Multiplies a Q15 vector by a scalar."]
    #[doc = " @param[in]  pSrc        points to the input vector"]
    #[doc = " @param[in]  scaleFract  fractional portion of the scale value"]
    #[doc = " @param[in]  shift       number of bits to shift the result by"]
    #[doc = " @param[out] pDst        points to the output vector"]
    #[doc = " @param[in]  blockSize   number of samples in the vector"]
    pub fn arm_scale_q15(
        pSrc: *const q15_t,
        scaleFract: q15_t,
        shift: i8,
        pDst: *mut q15_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Multiplies a Q31 vector by a scalar."]
    #[doc = " @param[in]  pSrc        points to the input vector"]
    #[doc = " @param[in]  scaleFract  fractional portion of the scale value"]
    #[doc = " @param[in]  shift       number of bits to shift the result by"]
    #[doc = " @param[out] pDst        points to the output vector"]
    #[doc = " @param[in]  blockSize   number of samples in the vector"]
    pub fn arm_scale_q31(
        pSrc: *const q31_t,
        scaleFract: q31_t,
        shift: i8,
        pDst: *mut q31_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Q7 vector absolute value."]
    #[doc = " @param[in]  pSrc       points to the input buffer"]
    #[doc = " @param[out] pDst       points to the output buffer"]
    #[doc = " @param[in]  blockSize  number of samples in each vector"]
    pub fn arm_abs_q7(pSrc: *const q7_t, pDst: *mut q7_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief Floating-point vector absolute value."]
    #[doc = " @param[in]  pSrc       points to the input buffer"]
    #[doc = " @param[out] pDst       points to the output buffer"]
    #[doc = " @param[in]  blockSize  number of samples in each vector"]
    pub fn arm_abs_f32(pSrc: *const float32_t, pDst: *mut float32_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief Q15 vector absolute value."]
    #[doc = " @param[in]  pSrc       points to the input buffer"]
    #[doc = " @param[out] pDst       points to the output buffer"]
    #[doc = " @param[in]  blockSize  number of samples in each vector"]
    pub fn arm_abs_q15(pSrc: *const q15_t, pDst: *mut q15_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief Q31 vector absolute value."]
    #[doc = " @param[in]  pSrc       points to the input buffer"]
    #[doc = " @param[out] pDst       points to the output buffer"]
    #[doc = " @param[in]  blockSize  number of samples in each vector"]
    pub fn arm_abs_q31(pSrc: *const q31_t, pDst: *mut q31_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief Dot product of floating-point vectors."]
    #[doc = " @param[in]  pSrcA      points to the first input vector"]
    #[doc = " @param[in]  pSrcB      points to the second input vector"]
    #[doc = " @param[in]  blockSize  number of samples in each vector"]
    #[doc = " @param[out] result     output result returned here"]
    pub fn arm_dot_prod_f32(
        pSrcA: *const float32_t,
        pSrcB: *const float32_t,
        blockSize: u32,
        result: *mut float32_t,
    );
}
extern "C" {
    #[doc = " @brief Dot product of Q7 vectors."]
    #[doc = " @param[in]  pSrcA      points to the first input vector"]
    #[doc = " @param[in]  pSrcB      points to the second input vector"]
    #[doc = " @param[in]  blockSize  number of samples in each vector"]
    #[doc = " @param[out] result     output result returned here"]
    pub fn arm_dot_prod_q7(
        pSrcA: *const q7_t,
        pSrcB: *const q7_t,
        blockSize: u32,
        result: *mut q31_t,
    );
}
extern "C" {
    #[doc = " @brief Dot product of Q15 vectors."]
    #[doc = " @param[in]  pSrcA      points to the first input vector"]
    #[doc = " @param[in]  pSrcB      points to the second input vector"]
    #[doc = " @param[in]  blockSize  number of samples in each vector"]
    #[doc = " @param[out] result     output result returned here"]
    pub fn arm_dot_prod_q15(
        pSrcA: *const q15_t,
        pSrcB: *const q15_t,
        blockSize: u32,
        result: *mut q63_t,
    );
}
extern "C" {
    #[doc = " @brief Dot product of Q31 vectors."]
    #[doc = " @param[in]  pSrcA      points to the first input vector"]
    #[doc = " @param[in]  pSrcB      points to the second input vector"]
    #[doc = " @param[in]  blockSize  number of samples in each vector"]
    #[doc = " @param[out] result     output result returned here"]
    pub fn arm_dot_prod_q31(
        pSrcA: *const q31_t,
        pSrcB: *const q31_t,
        blockSize: u32,
        result: *mut q63_t,
    );
}
extern "C" {
    #[doc = " @brief  Shifts the elements of a Q7 vector a specified number of bits."]
    #[doc = " @param[in]  pSrc       points to the input vector"]
    #[doc = " @param[in]  shiftBits  number of bits to shift.  A positive value shifts left; a negative value shifts right."]
    #[doc = " @param[out] pDst       points to the output vector"]
    #[doc = " @param[in]  blockSize  number of samples in the vector"]
    pub fn arm_shift_q7(pSrc: *const q7_t, shiftBits: i8, pDst: *mut q7_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  Shifts the elements of a Q15 vector a specified number of bits."]
    #[doc = " @param[in]  pSrc       points to the input vector"]
    #[doc = " @param[in]  shiftBits  number of bits to shift.  A positive value shifts left; a negative value shifts right."]
    #[doc = " @param[out] pDst       points to the output vector"]
    #[doc = " @param[in]  blockSize  number of samples in the vector"]
    pub fn arm_shift_q15(pSrc: *const q15_t, shiftBits: i8, pDst: *mut q15_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  Shifts the elements of a Q31 vector a specified number of bits."]
    #[doc = " @param[in]  pSrc       points to the input vector"]
    #[doc = " @param[in]  shiftBits  number of bits to shift.  A positive value shifts left; a negative value shifts right."]
    #[doc = " @param[out] pDst       points to the output vector"]
    #[doc = " @param[in]  blockSize  number of samples in the vector"]
    pub fn arm_shift_q31(pSrc: *const q31_t, shiftBits: i8, pDst: *mut q31_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  Adds a constant offset to a floating-point vector."]
    #[doc = " @param[in]  pSrc       points to the input vector"]
    #[doc = " @param[in]  offset     is the offset to be added"]
    #[doc = " @param[out] pDst       points to the output vector"]
    #[doc = " @param[in]  blockSize  number of samples in the vector"]
    pub fn arm_offset_f32(
        pSrc: *const float32_t,
        offset: float32_t,
        pDst: *mut float32_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief  Adds a constant offset to a Q7 vector."]
    #[doc = " @param[in]  pSrc       points to the input vector"]
    #[doc = " @param[in]  offset     is the offset to be added"]
    #[doc = " @param[out] pDst       points to the output vector"]
    #[doc = " @param[in]  blockSize  number of samples in the vector"]
    pub fn arm_offset_q7(pSrc: *const q7_t, offset: q7_t, pDst: *mut q7_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  Adds a constant offset to a Q15 vector."]
    #[doc = " @param[in]  pSrc       points to the input vector"]
    #[doc = " @param[in]  offset     is the offset to be added"]
    #[doc = " @param[out] pDst       points to the output vector"]
    #[doc = " @param[in]  blockSize  number of samples in the vector"]
    pub fn arm_offset_q15(pSrc: *const q15_t, offset: q15_t, pDst: *mut q15_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  Adds a constant offset to a Q31 vector."]
    #[doc = " @param[in]  pSrc       points to the input vector"]
    #[doc = " @param[in]  offset     is the offset to be added"]
    #[doc = " @param[out] pDst       points to the output vector"]
    #[doc = " @param[in]  blockSize  number of samples in the vector"]
    pub fn arm_offset_q31(pSrc: *const q31_t, offset: q31_t, pDst: *mut q31_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  Negates the elements of a floating-point vector."]
    #[doc = " @param[in]  pSrc       points to the input vector"]
    #[doc = " @param[out] pDst       points to the output vector"]
    #[doc = " @param[in]  blockSize  number of samples in the vector"]
    pub fn arm_negate_f32(pSrc: *const float32_t, pDst: *mut float32_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  Negates the elements of a Q7 vector."]
    #[doc = " @param[in]  pSrc       points to the input vector"]
    #[doc = " @param[out] pDst       points to the output vector"]
    #[doc = " @param[in]  blockSize  number of samples in the vector"]
    pub fn arm_negate_q7(pSrc: *const q7_t, pDst: *mut q7_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  Negates the elements of a Q15 vector."]
    #[doc = " @param[in]  pSrc       points to the input vector"]
    #[doc = " @param[out] pDst       points to the output vector"]
    #[doc = " @param[in]  blockSize  number of samples in the vector"]
    pub fn arm_negate_q15(pSrc: *const q15_t, pDst: *mut q15_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  Negates the elements of a Q31 vector."]
    #[doc = " @param[in]  pSrc       points to the input vector"]
    #[doc = " @param[out] pDst       points to the output vector"]
    #[doc = " @param[in]  blockSize  number of samples in the vector"]
    pub fn arm_negate_q31(pSrc: *const q31_t, pDst: *mut q31_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  Copies the elements of a floating-point vector."]
    #[doc = " @param[in]  pSrc       input pointer"]
    #[doc = " @param[out] pDst       output pointer"]
    #[doc = " @param[in]  blockSize  number of samples to process"]
    pub fn arm_copy_f32(pSrc: *const float32_t, pDst: *mut float32_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  Copies the elements of a Q7 vector."]
    #[doc = " @param[in]  pSrc       input pointer"]
    #[doc = " @param[out] pDst       output pointer"]
    #[doc = " @param[in]  blockSize  number of samples to process"]
    pub fn arm_copy_q7(pSrc: *const q7_t, pDst: *mut q7_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  Copies the elements of a Q15 vector."]
    #[doc = " @param[in]  pSrc       input pointer"]
    #[doc = " @param[out] pDst       output pointer"]
    #[doc = " @param[in]  blockSize  number of samples to process"]
    pub fn arm_copy_q15(pSrc: *const q15_t, pDst: *mut q15_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  Copies the elements of a Q31 vector."]
    #[doc = " @param[in]  pSrc       input pointer"]
    #[doc = " @param[out] pDst       output pointer"]
    #[doc = " @param[in]  blockSize  number of samples to process"]
    pub fn arm_copy_q31(pSrc: *const q31_t, pDst: *mut q31_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  Fills a constant value into a floating-point vector."]
    #[doc = " @param[in]  value      input value to be filled"]
    #[doc = " @param[out] pDst       output pointer"]
    #[doc = " @param[in]  blockSize  number of samples to process"]
    pub fn arm_fill_f32(value: float32_t, pDst: *mut float32_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  Fills a constant value into a Q7 vector."]
    #[doc = " @param[in]  value      input value to be filled"]
    #[doc = " @param[out] pDst       output pointer"]
    #[doc = " @param[in]  blockSize  number of samples to process"]
    pub fn arm_fill_q7(value: q7_t, pDst: *mut q7_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  Fills a constant value into a Q15 vector."]
    #[doc = " @param[in]  value      input value to be filled"]
    #[doc = " @param[out] pDst       output pointer"]
    #[doc = " @param[in]  blockSize  number of samples to process"]
    pub fn arm_fill_q15(value: q15_t, pDst: *mut q15_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  Fills a constant value into a Q31 vector."]
    #[doc = " @param[in]  value      input value to be filled"]
    #[doc = " @param[out] pDst       output pointer"]
    #[doc = " @param[in]  blockSize  number of samples to process"]
    pub fn arm_fill_q31(value: q31_t, pDst: *mut q31_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief Convolution of floating-point sequences."]
    #[doc = " @param[in]  pSrcA    points to the first input sequence."]
    #[doc = " @param[in]  srcALen  length of the first input sequence."]
    #[doc = " @param[in]  pSrcB    points to the second input sequence."]
    #[doc = " @param[in]  srcBLen  length of the second input sequence."]
    #[doc = " @param[out] pDst     points to the location where the output result is written.  Length srcALen+srcBLen-1."]
    pub fn arm_conv_f32(
        pSrcA: *const float32_t,
        srcALen: u32,
        pSrcB: *const float32_t,
        srcBLen: u32,
        pDst: *mut float32_t,
    );
}
extern "C" {
    #[doc = " @brief Convolution of Q15 sequences."]
    #[doc = " @param[in]  pSrcA      points to the first input sequence."]
    #[doc = " @param[in]  srcALen    length of the first input sequence."]
    #[doc = " @param[in]  pSrcB      points to the second input sequence."]
    #[doc = " @param[in]  srcBLen    length of the second input sequence."]
    #[doc = " @param[out] pDst       points to the block of output data  Length srcALen+srcBLen-1."]
    #[doc = " @param[in]  pScratch1  points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2."]
    #[doc = " @param[in]  pScratch2  points to scratch buffer of size min(srcALen, srcBLen)."]
    pub fn arm_conv_opt_q15(
        pSrcA: *const q15_t,
        srcALen: u32,
        pSrcB: *const q15_t,
        srcBLen: u32,
        pDst: *mut q15_t,
        pScratch1: *mut q15_t,
        pScratch2: *mut q15_t,
    );
}
extern "C" {
    #[doc = " @brief Convolution of Q15 sequences."]
    #[doc = " @param[in]  pSrcA    points to the first input sequence."]
    #[doc = " @param[in]  srcALen  length of the first input sequence."]
    #[doc = " @param[in]  pSrcB    points to the second input sequence."]
    #[doc = " @param[in]  srcBLen  length of the second input sequence."]
    #[doc = " @param[out] pDst     points to the location where the output result is written.  Length srcALen+srcBLen-1."]
    pub fn arm_conv_q15(
        pSrcA: *const q15_t,
        srcALen: u32,
        pSrcB: *const q15_t,
        srcBLen: u32,
        pDst: *mut q15_t,
    );
}
extern "C" {
    #[doc = " @brief Convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4"]
    #[doc = " @param[in]  pSrcA    points to the first input sequence."]
    #[doc = " @param[in]  srcALen  length of the first input sequence."]
    #[doc = " @param[in]  pSrcB    points to the second input sequence."]
    #[doc = " @param[in]  srcBLen  length of the second input sequence."]
    #[doc = " @param[out] pDst     points to the block of output data  Length srcALen+srcBLen-1."]
    pub fn arm_conv_fast_q15(
        pSrcA: *const q15_t,
        srcALen: u32,
        pSrcB: *const q15_t,
        srcBLen: u32,
        pDst: *mut q15_t,
    );
}
extern "C" {
    #[doc = " @brief Convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4"]
    #[doc = " @param[in]  pSrcA      points to the first input sequence."]
    #[doc = " @param[in]  srcALen    length of the first input sequence."]
    #[doc = " @param[in]  pSrcB      points to the second input sequence."]
    #[doc = " @param[in]  srcBLen    length of the second input sequence."]
    #[doc = " @param[out] pDst       points to the block of output data  Length srcALen+srcBLen-1."]
    #[doc = " @param[in]  pScratch1  points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2."]
    #[doc = " @param[in]  pScratch2  points to scratch buffer of size min(srcALen, srcBLen)."]
    pub fn arm_conv_fast_opt_q15(
        pSrcA: *const q15_t,
        srcALen: u32,
        pSrcB: *const q15_t,
        srcBLen: u32,
        pDst: *mut q15_t,
        pScratch1: *mut q15_t,
        pScratch2: *mut q15_t,
    );
}
extern "C" {
    #[doc = " @brief Convolution of Q31 sequences."]
    #[doc = " @param[in]  pSrcA    points to the first input sequence."]
    #[doc = " @param[in]  srcALen  length of the first input sequence."]
    #[doc = " @param[in]  pSrcB    points to the second input sequence."]
    #[doc = " @param[in]  srcBLen  length of the second input sequence."]
    #[doc = " @param[out] pDst     points to the block of output data  Length srcALen+srcBLen-1."]
    pub fn arm_conv_q31(
        pSrcA: *const q31_t,
        srcALen: u32,
        pSrcB: *const q31_t,
        srcBLen: u32,
        pDst: *mut q31_t,
    );
}
extern "C" {
    #[doc = " @brief Convolution of Q31 sequences (fast version) for Cortex-M3 and Cortex-M4"]
    #[doc = " @param[in]  pSrcA    points to the first input sequence."]
    #[doc = " @param[in]  srcALen  length of the first input sequence."]
    #[doc = " @param[in]  pSrcB    points to the second input sequence."]
    #[doc = " @param[in]  srcBLen  length of the second input sequence."]
    #[doc = " @param[out] pDst     points to the block of output data  Length srcALen+srcBLen-1."]
    pub fn arm_conv_fast_q31(
        pSrcA: *const q31_t,
        srcALen: u32,
        pSrcB: *const q31_t,
        srcBLen: u32,
        pDst: *mut q31_t,
    );
}
extern "C" {
    #[doc = " @brief Convolution of Q7 sequences."]
    #[doc = " @param[in]  pSrcA      points to the first input sequence."]
    #[doc = " @param[in]  srcALen    length of the first input sequence."]
    #[doc = " @param[in]  pSrcB      points to the second input sequence."]
    #[doc = " @param[in]  srcBLen    length of the second input sequence."]
    #[doc = " @param[out] pDst       points to the block of output data  Length srcALen+srcBLen-1."]
    #[doc = " @param[in]  pScratch1  points to scratch buffer(of type q15_t) of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2."]
    #[doc = " @param[in]  pScratch2  points to scratch buffer (of type q15_t) of size min(srcALen, srcBLen)."]
    pub fn arm_conv_opt_q7(
        pSrcA: *const q7_t,
        srcALen: u32,
        pSrcB: *const q7_t,
        srcBLen: u32,
        pDst: *mut q7_t,
        pScratch1: *mut q15_t,
        pScratch2: *mut q15_t,
    );
}
extern "C" {
    #[doc = " @brief Convolution of Q7 sequences."]
    #[doc = " @param[in]  pSrcA    points to the first input sequence."]
    #[doc = " @param[in]  srcALen  length of the first input sequence."]
    #[doc = " @param[in]  pSrcB    points to the second input sequence."]
    #[doc = " @param[in]  srcBLen  length of the second input sequence."]
    #[doc = " @param[out] pDst     points to the block of output data  Length srcALen+srcBLen-1."]
    pub fn arm_conv_q7(
        pSrcA: *const q7_t,
        srcALen: u32,
        pSrcB: *const q7_t,
        srcBLen: u32,
        pDst: *mut q7_t,
    );
}
extern "C" {
    #[doc = " @brief Partial convolution of floating-point sequences."]
    #[doc = " @param[in]  pSrcA       points to the first input sequence."]
    #[doc = " @param[in]  srcALen     length of the first input sequence."]
    #[doc = " @param[in]  pSrcB       points to the second input sequence."]
    #[doc = " @param[in]  srcBLen     length of the second input sequence."]
    #[doc = " @param[out] pDst        points to the block of output data"]
    #[doc = " @param[in]  firstIndex  is the first output sample to start with."]
    #[doc = " @param[in]  numPoints   is the number of output points to be computed."]
    #[doc = " @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2]."]
    pub fn arm_conv_partial_f32(
        pSrcA: *const float32_t,
        srcALen: u32,
        pSrcB: *const float32_t,
        srcBLen: u32,
        pDst: *mut float32_t,
        firstIndex: u32,
        numPoints: u32,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Partial convolution of Q15 sequences."]
    #[doc = " @param[in]  pSrcA       points to the first input sequence."]
    #[doc = " @param[in]  srcALen     length of the first input sequence."]
    #[doc = " @param[in]  pSrcB       points to the second input sequence."]
    #[doc = " @param[in]  srcBLen     length of the second input sequence."]
    #[doc = " @param[out] pDst        points to the block of output data"]
    #[doc = " @param[in]  firstIndex  is the first output sample to start with."]
    #[doc = " @param[in]  numPoints   is the number of output points to be computed."]
    #[doc = " @param[in]  pScratch1   points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2."]
    #[doc = " @param[in]  pScratch2   points to scratch buffer of size min(srcALen, srcBLen)."]
    #[doc = " @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2]."]
    pub fn arm_conv_partial_opt_q15(
        pSrcA: *const q15_t,
        srcALen: u32,
        pSrcB: *const q15_t,
        srcBLen: u32,
        pDst: *mut q15_t,
        firstIndex: u32,
        numPoints: u32,
        pScratch1: *mut q15_t,
        pScratch2: *mut q15_t,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Partial convolution of Q15 sequences."]
    #[doc = " @param[in]  pSrcA       points to the first input sequence."]
    #[doc = " @param[in]  srcALen     length of the first input sequence."]
    #[doc = " @param[in]  pSrcB       points to the second input sequence."]
    #[doc = " @param[in]  srcBLen     length of the second input sequence."]
    #[doc = " @param[out] pDst        points to the block of output data"]
    #[doc = " @param[in]  firstIndex  is the first output sample to start with."]
    #[doc = " @param[in]  numPoints   is the number of output points to be computed."]
    #[doc = " @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2]."]
    pub fn arm_conv_partial_q15(
        pSrcA: *const q15_t,
        srcALen: u32,
        pSrcB: *const q15_t,
        srcBLen: u32,
        pDst: *mut q15_t,
        firstIndex: u32,
        numPoints: u32,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Partial convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4"]
    #[doc = " @param[in]  pSrcA       points to the first input sequence."]
    #[doc = " @param[in]  srcALen     length of the first input sequence."]
    #[doc = " @param[in]  pSrcB       points to the second input sequence."]
    #[doc = " @param[in]  srcBLen     length of the second input sequence."]
    #[doc = " @param[out] pDst        points to the block of output data"]
    #[doc = " @param[in]  firstIndex  is the first output sample to start with."]
    #[doc = " @param[in]  numPoints   is the number of output points to be computed."]
    #[doc = " @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2]."]
    pub fn arm_conv_partial_fast_q15(
        pSrcA: *const q15_t,
        srcALen: u32,
        pSrcB: *const q15_t,
        srcBLen: u32,
        pDst: *mut q15_t,
        firstIndex: u32,
        numPoints: u32,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Partial convolution of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4"]
    #[doc = " @param[in]  pSrcA       points to the first input sequence."]
    #[doc = " @param[in]  srcALen     length of the first input sequence."]
    #[doc = " @param[in]  pSrcB       points to the second input sequence."]
    #[doc = " @param[in]  srcBLen     length of the second input sequence."]
    #[doc = " @param[out] pDst        points to the block of output data"]
    #[doc = " @param[in]  firstIndex  is the first output sample to start with."]
    #[doc = " @param[in]  numPoints   is the number of output points to be computed."]
    #[doc = " @param[in]  pScratch1   points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2."]
    #[doc = " @param[in]  pScratch2   points to scratch buffer of size min(srcALen, srcBLen)."]
    #[doc = " @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2]."]
    pub fn arm_conv_partial_fast_opt_q15(
        pSrcA: *const q15_t,
        srcALen: u32,
        pSrcB: *const q15_t,
        srcBLen: u32,
        pDst: *mut q15_t,
        firstIndex: u32,
        numPoints: u32,
        pScratch1: *mut q15_t,
        pScratch2: *mut q15_t,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Partial convolution of Q31 sequences."]
    #[doc = " @param[in]  pSrcA       points to the first input sequence."]
    #[doc = " @param[in]  srcALen     length of the first input sequence."]
    #[doc = " @param[in]  pSrcB       points to the second input sequence."]
    #[doc = " @param[in]  srcBLen     length of the second input sequence."]
    #[doc = " @param[out] pDst        points to the block of output data"]
    #[doc = " @param[in]  firstIndex  is the first output sample to start with."]
    #[doc = " @param[in]  numPoints   is the number of output points to be computed."]
    #[doc = " @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2]."]
    pub fn arm_conv_partial_q31(
        pSrcA: *const q31_t,
        srcALen: u32,
        pSrcB: *const q31_t,
        srcBLen: u32,
        pDst: *mut q31_t,
        firstIndex: u32,
        numPoints: u32,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Partial convolution of Q31 sequences (fast version) for Cortex-M3 and Cortex-M4"]
    #[doc = " @param[in]  pSrcA       points to the first input sequence."]
    #[doc = " @param[in]  srcALen     length of the first input sequence."]
    #[doc = " @param[in]  pSrcB       points to the second input sequence."]
    #[doc = " @param[in]  srcBLen     length of the second input sequence."]
    #[doc = " @param[out] pDst        points to the block of output data"]
    #[doc = " @param[in]  firstIndex  is the first output sample to start with."]
    #[doc = " @param[in]  numPoints   is the number of output points to be computed."]
    #[doc = " @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2]."]
    pub fn arm_conv_partial_fast_q31(
        pSrcA: *const q31_t,
        srcALen: u32,
        pSrcB: *const q31_t,
        srcBLen: u32,
        pDst: *mut q31_t,
        firstIndex: u32,
        numPoints: u32,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Partial convolution of Q7 sequences"]
    #[doc = " @param[in]  pSrcA       points to the first input sequence."]
    #[doc = " @param[in]  srcALen     length of the first input sequence."]
    #[doc = " @param[in]  pSrcB       points to the second input sequence."]
    #[doc = " @param[in]  srcBLen     length of the second input sequence."]
    #[doc = " @param[out] pDst        points to the block of output data"]
    #[doc = " @param[in]  firstIndex  is the first output sample to start with."]
    #[doc = " @param[in]  numPoints   is the number of output points to be computed."]
    #[doc = " @param[in]  pScratch1   points to scratch buffer(of type q15_t) of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2."]
    #[doc = " @param[in]  pScratch2   points to scratch buffer (of type q15_t) of size min(srcALen, srcBLen)."]
    #[doc = " @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2]."]
    pub fn arm_conv_partial_opt_q7(
        pSrcA: *const q7_t,
        srcALen: u32,
        pSrcB: *const q7_t,
        srcBLen: u32,
        pDst: *mut q7_t,
        firstIndex: u32,
        numPoints: u32,
        pScratch1: *mut q15_t,
        pScratch2: *mut q15_t,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Partial convolution of Q7 sequences."]
    #[doc = " @param[in]  pSrcA       points to the first input sequence."]
    #[doc = " @param[in]  srcALen     length of the first input sequence."]
    #[doc = " @param[in]  pSrcB       points to the second input sequence."]
    #[doc = " @param[in]  srcBLen     length of the second input sequence."]
    #[doc = " @param[out] pDst        points to the block of output data"]
    #[doc = " @param[in]  firstIndex  is the first output sample to start with."]
    #[doc = " @param[in]  numPoints   is the number of output points to be computed."]
    #[doc = " @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2]."]
    pub fn arm_conv_partial_q7(
        pSrcA: *const q7_t,
        srcALen: u32,
        pSrcB: *const q7_t,
        srcBLen: u32,
        pDst: *mut q7_t,
        firstIndex: u32,
        numPoints: u32,
    ) -> arm_status::Type;
}
#[doc = " @brief Instance structure for the Q15 FIR decimator."]
#[repr(C)]
pub struct arm_fir_decimate_instance_q15 {
    #[doc = "< decimation factor."]
    pub M: u8,
    #[doc = "< number of coefficients in the filter."]
    pub numTaps: u16,
    #[doc = "< points to the coefficient array. The array is of length numTaps."]
    pub pCoeffs: *const q15_t,
    #[doc = "< points to the state variable array. The array is of length numTaps+blockSize-1."]
    pub pState: *mut q15_t,
}
#[test]
fn bindgen_test_layout_arm_fir_decimate_instance_q15() {
    assert_eq!(
        ::core::mem::size_of::<arm_fir_decimate_instance_q15>(),
        24usize,
        concat!("Size of: ", stringify!(arm_fir_decimate_instance_q15))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_fir_decimate_instance_q15>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_fir_decimate_instance_q15))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_decimate_instance_q15>())).M as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_decimate_instance_q15),
            "::",
            stringify!(M)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_decimate_instance_q15>())).numTaps as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_decimate_instance_q15),
            "::",
            stringify!(numTaps)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_decimate_instance_q15>())).pCoeffs as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_decimate_instance_q15),
            "::",
            stringify!(pCoeffs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_decimate_instance_q15>())).pState as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_decimate_instance_q15),
            "::",
            stringify!(pState)
        )
    );
}
#[doc = " @brief Instance structure for the Q31 FIR decimator."]
#[repr(C)]
pub struct arm_fir_decimate_instance_q31 {
    #[doc = "< decimation factor."]
    pub M: u8,
    #[doc = "< number of coefficients in the filter."]
    pub numTaps: u16,
    #[doc = "< points to the coefficient array. The array is of length numTaps."]
    pub pCoeffs: *const q31_t,
    #[doc = "< points to the state variable array. The array is of length numTaps+blockSize-1."]
    pub pState: *mut q31_t,
}
#[test]
fn bindgen_test_layout_arm_fir_decimate_instance_q31() {
    assert_eq!(
        ::core::mem::size_of::<arm_fir_decimate_instance_q31>(),
        24usize,
        concat!("Size of: ", stringify!(arm_fir_decimate_instance_q31))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_fir_decimate_instance_q31>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_fir_decimate_instance_q31))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_decimate_instance_q31>())).M as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_decimate_instance_q31),
            "::",
            stringify!(M)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_decimate_instance_q31>())).numTaps as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_decimate_instance_q31),
            "::",
            stringify!(numTaps)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_decimate_instance_q31>())).pCoeffs as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_decimate_instance_q31),
            "::",
            stringify!(pCoeffs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_decimate_instance_q31>())).pState as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_decimate_instance_q31),
            "::",
            stringify!(pState)
        )
    );
}
#[doc = "@brief Instance structure for floating-point FIR decimator."]
#[repr(C)]
pub struct arm_fir_decimate_instance_f32 {
    #[doc = "< decimation factor."]
    pub M: u8,
    #[doc = "< number of coefficients in the filter."]
    pub numTaps: u16,
    #[doc = "< points to the coefficient array. The array is of length numTaps."]
    pub pCoeffs: *const float32_t,
    #[doc = "< points to the state variable array. The array is of length numTaps+blockSize-1."]
    pub pState: *mut float32_t,
}
#[test]
fn bindgen_test_layout_arm_fir_decimate_instance_f32() {
    assert_eq!(
        ::core::mem::size_of::<arm_fir_decimate_instance_f32>(),
        24usize,
        concat!("Size of: ", stringify!(arm_fir_decimate_instance_f32))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_fir_decimate_instance_f32>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_fir_decimate_instance_f32))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_decimate_instance_f32>())).M as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_decimate_instance_f32),
            "::",
            stringify!(M)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_decimate_instance_f32>())).numTaps as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_decimate_instance_f32),
            "::",
            stringify!(numTaps)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_decimate_instance_f32>())).pCoeffs as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_decimate_instance_f32),
            "::",
            stringify!(pCoeffs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_decimate_instance_f32>())).pState as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_decimate_instance_f32),
            "::",
            stringify!(pState)
        )
    );
}
extern "C" {
    #[doc = "@brief         Processing function for floating-point FIR decimator."]
    #[doc = "@param[in]     S         points to an instance of the floating-point FIR decimator structure"]
    #[doc = "@param[in]     pSrc      points to the block of input data"]
    #[doc = "@param[out]    pDst      points to the block of output data"]
    #[doc = "@param[in]     blockSize number of samples to process"]
    pub fn arm_fir_decimate_f32(
        S: *const arm_fir_decimate_instance_f32,
        pSrc: *const float32_t,
        pDst: *mut float32_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = "@brief         Initialization function for the floating-point FIR decimator."]
    #[doc = "@param[in,out] S          points to an instance of the floating-point FIR decimator structure"]
    #[doc = "@param[in]     numTaps    number of coefficients in the filter"]
    #[doc = "@param[in]     M          decimation factor"]
    #[doc = "@param[in]     pCoeffs    points to the filter coefficients"]
    #[doc = "@param[in]     pState     points to the state buffer"]
    #[doc = "@param[in]     blockSize  number of input samples to process per call"]
    #[doc = "@return        execution status"]
    #[doc = "- \\ref ARM_MATH_SUCCESS      : Operation successful"]
    #[doc = "- \\ref ARM_MATH_LENGTH_ERROR : <code>blockSize</code> is not a multiple of <code>M</code>"]
    pub fn arm_fir_decimate_init_f32(
        S: *mut arm_fir_decimate_instance_f32,
        numTaps: u16,
        M: u8,
        pCoeffs: *const float32_t,
        pState: *mut float32_t,
        blockSize: u32,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Processing function for the Q15 FIR decimator."]
    #[doc = " @param[in]  S          points to an instance of the Q15 FIR decimator structure."]
    #[doc = " @param[in]  pSrc       points to the block of input data."]
    #[doc = " @param[out] pDst       points to the block of output data"]
    #[doc = " @param[in]  blockSize  number of input samples to process per call."]
    pub fn arm_fir_decimate_q15(
        S: *const arm_fir_decimate_instance_q15,
        pSrc: *const q15_t,
        pDst: *mut q15_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Processing function for the Q15 FIR decimator (fast variant) for Cortex-M3 and Cortex-M4."]
    #[doc = " @param[in]  S          points to an instance of the Q15 FIR decimator structure."]
    #[doc = " @param[in]  pSrc       points to the block of input data."]
    #[doc = " @param[out] pDst       points to the block of output data"]
    #[doc = " @param[in]  blockSize  number of input samples to process per call."]
    pub fn arm_fir_decimate_fast_q15(
        S: *const arm_fir_decimate_instance_q15,
        pSrc: *const q15_t,
        pDst: *mut q15_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief  Initialization function for the Q15 FIR decimator."]
    #[doc = " @param[in,out] S          points to an instance of the Q15 FIR decimator structure."]
    #[doc = " @param[in]     numTaps    number of coefficients in the filter."]
    #[doc = " @param[in]     M          decimation factor."]
    #[doc = " @param[in]     pCoeffs    points to the filter coefficients."]
    #[doc = " @param[in]     pState     points to the state buffer."]
    #[doc = " @param[in]     blockSize  number of input samples to process per call."]
    #[doc = " @return    The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_LENGTH_ERROR if"]
    #[doc = " <code>blockSize</code> is not a multiple of <code>M</code>."]
    pub fn arm_fir_decimate_init_q15(
        S: *mut arm_fir_decimate_instance_q15,
        numTaps: u16,
        M: u8,
        pCoeffs: *const q15_t,
        pState: *mut q15_t,
        blockSize: u32,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Processing function for the Q31 FIR decimator."]
    #[doc = " @param[in]  S     points to an instance of the Q31 FIR decimator structure."]
    #[doc = " @param[in]  pSrc  points to the block of input data."]
    #[doc = " @param[out] pDst  points to the block of output data"]
    #[doc = " @param[in] blockSize number of input samples to process per call."]
    pub fn arm_fir_decimate_q31(
        S: *const arm_fir_decimate_instance_q31,
        pSrc: *const q31_t,
        pDst: *mut q31_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Processing function for the Q31 FIR decimator (fast variant) for Cortex-M3 and Cortex-M4."]
    #[doc = " @param[in]  S          points to an instance of the Q31 FIR decimator structure."]
    #[doc = " @param[in]  pSrc       points to the block of input data."]
    #[doc = " @param[out] pDst       points to the block of output data"]
    #[doc = " @param[in]  blockSize  number of input samples to process per call."]
    pub fn arm_fir_decimate_fast_q31(
        S: *const arm_fir_decimate_instance_q31,
        pSrc: *const q31_t,
        pDst: *mut q31_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief  Initialization function for the Q31 FIR decimator."]
    #[doc = " @param[in,out] S          points to an instance of the Q31 FIR decimator structure."]
    #[doc = " @param[in]     numTaps    number of coefficients in the filter."]
    #[doc = " @param[in]     M          decimation factor."]
    #[doc = " @param[in]     pCoeffs    points to the filter coefficients."]
    #[doc = " @param[in]     pState     points to the state buffer."]
    #[doc = " @param[in]     blockSize  number of input samples to process per call."]
    #[doc = " @return    The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_LENGTH_ERROR if"]
    #[doc = " <code>blockSize</code> is not a multiple of <code>M</code>."]
    pub fn arm_fir_decimate_init_q31(
        S: *mut arm_fir_decimate_instance_q31,
        numTaps: u16,
        M: u8,
        pCoeffs: *const q31_t,
        pState: *mut q31_t,
        blockSize: u32,
    ) -> arm_status::Type;
}
#[doc = " @brief Instance structure for the Q15 FIR interpolator."]
#[repr(C)]
pub struct arm_fir_interpolate_instance_q15 {
    #[doc = "< upsample factor."]
    pub L: u8,
    #[doc = "< length of each polyphase filter component."]
    pub phaseLength: u16,
    #[doc = "< points to the coefficient array. The array is of length L*phaseLength."]
    pub pCoeffs: *const q15_t,
    #[doc = "< points to the state variable array. The array is of length blockSize+phaseLength-1."]
    pub pState: *mut q15_t,
}
#[test]
fn bindgen_test_layout_arm_fir_interpolate_instance_q15() {
    assert_eq!(
        ::core::mem::size_of::<arm_fir_interpolate_instance_q15>(),
        24usize,
        concat!("Size of: ", stringify!(arm_fir_interpolate_instance_q15))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_fir_interpolate_instance_q15>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(arm_fir_interpolate_instance_q15)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_interpolate_instance_q15>())).L as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_interpolate_instance_q15),
            "::",
            stringify!(L)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_interpolate_instance_q15>())).phaseLength as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_interpolate_instance_q15),
            "::",
            stringify!(phaseLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_interpolate_instance_q15>())).pCoeffs as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_interpolate_instance_q15),
            "::",
            stringify!(pCoeffs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_interpolate_instance_q15>())).pState as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_interpolate_instance_q15),
            "::",
            stringify!(pState)
        )
    );
}
#[doc = " @brief Instance structure for the Q31 FIR interpolator."]
#[repr(C)]
pub struct arm_fir_interpolate_instance_q31 {
    #[doc = "< upsample factor."]
    pub L: u8,
    #[doc = "< length of each polyphase filter component."]
    pub phaseLength: u16,
    #[doc = "< points to the coefficient array. The array is of length L*phaseLength."]
    pub pCoeffs: *const q31_t,
    #[doc = "< points to the state variable array. The array is of length blockSize+phaseLength-1."]
    pub pState: *mut q31_t,
}
#[test]
fn bindgen_test_layout_arm_fir_interpolate_instance_q31() {
    assert_eq!(
        ::core::mem::size_of::<arm_fir_interpolate_instance_q31>(),
        24usize,
        concat!("Size of: ", stringify!(arm_fir_interpolate_instance_q31))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_fir_interpolate_instance_q31>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(arm_fir_interpolate_instance_q31)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_interpolate_instance_q31>())).L as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_interpolate_instance_q31),
            "::",
            stringify!(L)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_interpolate_instance_q31>())).phaseLength as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_interpolate_instance_q31),
            "::",
            stringify!(phaseLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_interpolate_instance_q31>())).pCoeffs as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_interpolate_instance_q31),
            "::",
            stringify!(pCoeffs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_interpolate_instance_q31>())).pState as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_interpolate_instance_q31),
            "::",
            stringify!(pState)
        )
    );
}
#[doc = " @brief Instance structure for the floating-point FIR interpolator."]
#[repr(C)]
pub struct arm_fir_interpolate_instance_f32 {
    #[doc = "< upsample factor."]
    pub L: u8,
    #[doc = "< length of each polyphase filter component."]
    pub phaseLength: u16,
    #[doc = "< points to the coefficient array. The array is of length L*phaseLength."]
    pub pCoeffs: *const float32_t,
    #[doc = "< points to the state variable array. The array is of length phaseLength+numTaps-1."]
    pub pState: *mut float32_t,
}
#[test]
fn bindgen_test_layout_arm_fir_interpolate_instance_f32() {
    assert_eq!(
        ::core::mem::size_of::<arm_fir_interpolate_instance_f32>(),
        24usize,
        concat!("Size of: ", stringify!(arm_fir_interpolate_instance_f32))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_fir_interpolate_instance_f32>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(arm_fir_interpolate_instance_f32)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_interpolate_instance_f32>())).L as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_interpolate_instance_f32),
            "::",
            stringify!(L)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_interpolate_instance_f32>())).phaseLength as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_interpolate_instance_f32),
            "::",
            stringify!(phaseLength)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_interpolate_instance_f32>())).pCoeffs as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_interpolate_instance_f32),
            "::",
            stringify!(pCoeffs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_interpolate_instance_f32>())).pState as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_interpolate_instance_f32),
            "::",
            stringify!(pState)
        )
    );
}
extern "C" {
    #[doc = " @brief Processing function for the Q15 FIR interpolator."]
    #[doc = " @param[in]  S          points to an instance of the Q15 FIR interpolator structure."]
    #[doc = " @param[in]  pSrc       points to the block of input data."]
    #[doc = " @param[out] pDst       points to the block of output data."]
    #[doc = " @param[in]  blockSize  number of input samples to process per call."]
    pub fn arm_fir_interpolate_q15(
        S: *const arm_fir_interpolate_instance_q15,
        pSrc: *const q15_t,
        pDst: *mut q15_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief  Initialization function for the Q15 FIR interpolator."]
    #[doc = " @param[in,out] S          points to an instance of the Q15 FIR interpolator structure."]
    #[doc = " @param[in]     L          upsample factor."]
    #[doc = " @param[in]     numTaps    number of filter coefficients in the filter."]
    #[doc = " @param[in]     pCoeffs    points to the filter coefficient buffer."]
    #[doc = " @param[in]     pState     points to the state buffer."]
    #[doc = " @param[in]     blockSize  number of input samples to process per call."]
    #[doc = " @return        The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_LENGTH_ERROR if"]
    #[doc = " the filter length <code>numTaps</code> is not a multiple of the interpolation factor <code>L</code>."]
    pub fn arm_fir_interpolate_init_q15(
        S: *mut arm_fir_interpolate_instance_q15,
        L: u8,
        numTaps: u16,
        pCoeffs: *const q15_t,
        pState: *mut q15_t,
        blockSize: u32,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Processing function for the Q31 FIR interpolator."]
    #[doc = " @param[in]  S          points to an instance of the Q15 FIR interpolator structure."]
    #[doc = " @param[in]  pSrc       points to the block of input data."]
    #[doc = " @param[out] pDst       points to the block of output data."]
    #[doc = " @param[in]  blockSize  number of input samples to process per call."]
    pub fn arm_fir_interpolate_q31(
        S: *const arm_fir_interpolate_instance_q31,
        pSrc: *const q31_t,
        pDst: *mut q31_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief  Initialization function for the Q31 FIR interpolator."]
    #[doc = " @param[in,out] S          points to an instance of the Q31 FIR interpolator structure."]
    #[doc = " @param[in]     L          upsample factor."]
    #[doc = " @param[in]     numTaps    number of filter coefficients in the filter."]
    #[doc = " @param[in]     pCoeffs    points to the filter coefficient buffer."]
    #[doc = " @param[in]     pState     points to the state buffer."]
    #[doc = " @param[in]     blockSize  number of input samples to process per call."]
    #[doc = " @return        The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_LENGTH_ERROR if"]
    #[doc = " the filter length <code>numTaps</code> is not a multiple of the interpolation factor <code>L</code>."]
    pub fn arm_fir_interpolate_init_q31(
        S: *mut arm_fir_interpolate_instance_q31,
        L: u8,
        numTaps: u16,
        pCoeffs: *const q31_t,
        pState: *mut q31_t,
        blockSize: u32,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Processing function for the floating-point FIR interpolator."]
    #[doc = " @param[in]  S          points to an instance of the floating-point FIR interpolator structure."]
    #[doc = " @param[in]  pSrc       points to the block of input data."]
    #[doc = " @param[out] pDst       points to the block of output data."]
    #[doc = " @param[in]  blockSize  number of input samples to process per call."]
    pub fn arm_fir_interpolate_f32(
        S: *const arm_fir_interpolate_instance_f32,
        pSrc: *const float32_t,
        pDst: *mut float32_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief  Initialization function for the floating-point FIR interpolator."]
    #[doc = " @param[in,out] S          points to an instance of the floating-point FIR interpolator structure."]
    #[doc = " @param[in]     L          upsample factor."]
    #[doc = " @param[in]     numTaps    number of filter coefficients in the filter."]
    #[doc = " @param[in]     pCoeffs    points to the filter coefficient buffer."]
    #[doc = " @param[in]     pState     points to the state buffer."]
    #[doc = " @param[in]     blockSize  number of input samples to process per call."]
    #[doc = " @return        The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_LENGTH_ERROR if"]
    #[doc = " the filter length <code>numTaps</code> is not a multiple of the interpolation factor <code>L</code>."]
    pub fn arm_fir_interpolate_init_f32(
        S: *mut arm_fir_interpolate_instance_f32,
        L: u8,
        numTaps: u16,
        pCoeffs: *const float32_t,
        pState: *mut float32_t,
        blockSize: u32,
    ) -> arm_status::Type;
}
#[doc = " @brief Instance structure for the high precision Q31 Biquad cascade filter."]
#[repr(C)]
pub struct arm_biquad_cas_df1_32x64_ins_q31 {
    #[doc = "< number of 2nd order stages in the filter.  Overall order is 2*numStages."]
    pub numStages: u8,
    #[doc = "< points to the array of state coefficients.  The array is of length 4*numStages."]
    pub pState: *mut q63_t,
    #[doc = "< points to the array of coefficients.  The array is of length 5*numStages."]
    pub pCoeffs: *const q31_t,
    #[doc = "< additional shift, in bits, applied to each output sample."]
    pub postShift: u8,
}
#[test]
fn bindgen_test_layout_arm_biquad_cas_df1_32x64_ins_q31() {
    assert_eq!(
        ::core::mem::size_of::<arm_biquad_cas_df1_32x64_ins_q31>(),
        32usize,
        concat!("Size of: ", stringify!(arm_biquad_cas_df1_32x64_ins_q31))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_biquad_cas_df1_32x64_ins_q31>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(arm_biquad_cas_df1_32x64_ins_q31)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_biquad_cas_df1_32x64_ins_q31>())).numStages as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_biquad_cas_df1_32x64_ins_q31),
            "::",
            stringify!(numStages)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_biquad_cas_df1_32x64_ins_q31>())).pState as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_biquad_cas_df1_32x64_ins_q31),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_biquad_cas_df1_32x64_ins_q31>())).pCoeffs as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_biquad_cas_df1_32x64_ins_q31),
            "::",
            stringify!(pCoeffs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_biquad_cas_df1_32x64_ins_q31>())).postShift as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_biquad_cas_df1_32x64_ins_q31),
            "::",
            stringify!(postShift)
        )
    );
}
extern "C" {
    #[doc = " @param[in]  S          points to an instance of the high precision Q31 Biquad cascade filter structure."]
    #[doc = " @param[in]  pSrc       points to the block of input data."]
    #[doc = " @param[out] pDst       points to the block of output data"]
    #[doc = " @param[in]  blockSize  number of samples to process."]
    pub fn arm_biquad_cas_df1_32x64_q31(
        S: *const arm_biquad_cas_df1_32x64_ins_q31,
        pSrc: *mut q31_t,
        pDst: *mut q31_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @param[in,out] S          points to an instance of the high precision Q31 Biquad cascade filter structure."]
    #[doc = " @param[in]     numStages  number of 2nd order stages in the filter."]
    #[doc = " @param[in]     pCoeffs    points to the filter coefficients."]
    #[doc = " @param[in]     pState     points to the state buffer."]
    #[doc = " @param[in]     postShift  shift to be applied to the output. Varies according to the coefficients format"]
    pub fn arm_biquad_cas_df1_32x64_init_q31(
        S: *mut arm_biquad_cas_df1_32x64_ins_q31,
        numStages: u8,
        pCoeffs: *const q31_t,
        pState: *mut q63_t,
        postShift: u8,
    );
}
#[doc = " @brief Instance structure for the floating-point transposed direct form II Biquad cascade filter."]
#[repr(C)]
pub struct arm_biquad_cascade_df2T_instance_f32 {
    #[doc = "< number of 2nd order stages in the filter.  Overall order is 2*numStages."]
    pub numStages: u8,
    #[doc = "< points to the array of state coefficients.  The array is of length 2*numStages."]
    pub pState: *mut float32_t,
    #[doc = "< points to the array of coefficients.  The array is of length 5*numStages."]
    pub pCoeffs: *const float32_t,
}
#[test]
fn bindgen_test_layout_arm_biquad_cascade_df2T_instance_f32() {
    assert_eq!(
        ::core::mem::size_of::<arm_biquad_cascade_df2T_instance_f32>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(arm_biquad_cascade_df2T_instance_f32)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<arm_biquad_cascade_df2T_instance_f32>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(arm_biquad_cascade_df2T_instance_f32)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_biquad_cascade_df2T_instance_f32>())).numStages as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_biquad_cascade_df2T_instance_f32),
            "::",
            stringify!(numStages)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_biquad_cascade_df2T_instance_f32>())).pState as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_biquad_cascade_df2T_instance_f32),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_biquad_cascade_df2T_instance_f32>())).pCoeffs as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_biquad_cascade_df2T_instance_f32),
            "::",
            stringify!(pCoeffs)
        )
    );
}
#[doc = " @brief Instance structure for the floating-point transposed direct form II Biquad cascade filter."]
#[repr(C)]
pub struct arm_biquad_cascade_stereo_df2T_instance_f32 {
    #[doc = "< number of 2nd order stages in the filter.  Overall order is 2*numStages."]
    pub numStages: u8,
    #[doc = "< points to the array of state coefficients.  The array is of length 4*numStages."]
    pub pState: *mut float32_t,
    #[doc = "< points to the array of coefficients.  The array is of length 5*numStages."]
    pub pCoeffs: *const float32_t,
}
#[test]
fn bindgen_test_layout_arm_biquad_cascade_stereo_df2T_instance_f32() {
    assert_eq!(
        ::core::mem::size_of::<arm_biquad_cascade_stereo_df2T_instance_f32>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(arm_biquad_cascade_stereo_df2T_instance_f32)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<arm_biquad_cascade_stereo_df2T_instance_f32>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(arm_biquad_cascade_stereo_df2T_instance_f32)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_biquad_cascade_stereo_df2T_instance_f32>())).numStages
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_biquad_cascade_stereo_df2T_instance_f32),
            "::",
            stringify!(numStages)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_biquad_cascade_stereo_df2T_instance_f32>())).pState
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_biquad_cascade_stereo_df2T_instance_f32),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_biquad_cascade_stereo_df2T_instance_f32>())).pCoeffs
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_biquad_cascade_stereo_df2T_instance_f32),
            "::",
            stringify!(pCoeffs)
        )
    );
}
#[doc = " @brief Instance structure for the floating-point transposed direct form II Biquad cascade filter."]
#[repr(C)]
pub struct arm_biquad_cascade_df2T_instance_f64 {
    #[doc = "< number of 2nd order stages in the filter.  Overall order is 2*numStages."]
    pub numStages: u8,
    #[doc = "< points to the array of state coefficients.  The array is of length 2*numStages."]
    pub pState: *mut float64_t,
    #[doc = "< points to the array of coefficients.  The array is of length 5*numStages."]
    pub pCoeffs: *mut float64_t,
}
#[test]
fn bindgen_test_layout_arm_biquad_cascade_df2T_instance_f64() {
    assert_eq!(
        ::core::mem::size_of::<arm_biquad_cascade_df2T_instance_f64>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(arm_biquad_cascade_df2T_instance_f64)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<arm_biquad_cascade_df2T_instance_f64>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(arm_biquad_cascade_df2T_instance_f64)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_biquad_cascade_df2T_instance_f64>())).numStages as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_biquad_cascade_df2T_instance_f64),
            "::",
            stringify!(numStages)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_biquad_cascade_df2T_instance_f64>())).pState as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_biquad_cascade_df2T_instance_f64),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_biquad_cascade_df2T_instance_f64>())).pCoeffs as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_biquad_cascade_df2T_instance_f64),
            "::",
            stringify!(pCoeffs)
        )
    );
}
extern "C" {
    #[doc = " @brief Processing function for the floating-point transposed direct form II Biquad cascade filter."]
    #[doc = " @param[in]  S          points to an instance of the filter data structure."]
    #[doc = " @param[in]  pSrc       points to the block of input data."]
    #[doc = " @param[out] pDst       points to the block of output data"]
    #[doc = " @param[in]  blockSize  number of samples to process."]
    pub fn arm_biquad_cascade_df2T_f32(
        S: *const arm_biquad_cascade_df2T_instance_f32,
        pSrc: *const float32_t,
        pDst: *mut float32_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Processing function for the floating-point transposed direct form II Biquad cascade filter. 2 channels"]
    #[doc = " @param[in]  S          points to an instance of the filter data structure."]
    #[doc = " @param[in]  pSrc       points to the block of input data."]
    #[doc = " @param[out] pDst       points to the block of output data"]
    #[doc = " @param[in]  blockSize  number of samples to process."]
    pub fn arm_biquad_cascade_stereo_df2T_f32(
        S: *const arm_biquad_cascade_stereo_df2T_instance_f32,
        pSrc: *const float32_t,
        pDst: *mut float32_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Processing function for the floating-point transposed direct form II Biquad cascade filter."]
    #[doc = " @param[in]  S          points to an instance of the filter data structure."]
    #[doc = " @param[in]  pSrc       points to the block of input data."]
    #[doc = " @param[out] pDst       points to the block of output data"]
    #[doc = " @param[in]  blockSize  number of samples to process."]
    pub fn arm_biquad_cascade_df2T_f64(
        S: *const arm_biquad_cascade_df2T_instance_f64,
        pSrc: *mut float64_t,
        pDst: *mut float64_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief  Initialization function for the floating-point transposed direct form II Biquad cascade filter."]
    #[doc = " @param[in,out] S          points to an instance of the filter data structure."]
    #[doc = " @param[in]     numStages  number of 2nd order stages in the filter."]
    #[doc = " @param[in]     pCoeffs    points to the filter coefficients."]
    #[doc = " @param[in]     pState     points to the state buffer."]
    pub fn arm_biquad_cascade_df2T_init_f32(
        S: *mut arm_biquad_cascade_df2T_instance_f32,
        numStages: u8,
        pCoeffs: *const float32_t,
        pState: *mut float32_t,
    );
}
extern "C" {
    #[doc = " @brief  Initialization function for the floating-point transposed direct form II Biquad cascade filter."]
    #[doc = " @param[in,out] S          points to an instance of the filter data structure."]
    #[doc = " @param[in]     numStages  number of 2nd order stages in the filter."]
    #[doc = " @param[in]     pCoeffs    points to the filter coefficients."]
    #[doc = " @param[in]     pState     points to the state buffer."]
    pub fn arm_biquad_cascade_stereo_df2T_init_f32(
        S: *mut arm_biquad_cascade_stereo_df2T_instance_f32,
        numStages: u8,
        pCoeffs: *const float32_t,
        pState: *mut float32_t,
    );
}
extern "C" {
    #[doc = " @brief  Initialization function for the floating-point transposed direct form II Biquad cascade filter."]
    #[doc = " @param[in,out] S          points to an instance of the filter data structure."]
    #[doc = " @param[in]     numStages  number of 2nd order stages in the filter."]
    #[doc = " @param[in]     pCoeffs    points to the filter coefficients."]
    #[doc = " @param[in]     pState     points to the state buffer."]
    pub fn arm_biquad_cascade_df2T_init_f64(
        S: *mut arm_biquad_cascade_df2T_instance_f64,
        numStages: u8,
        pCoeffs: *mut float64_t,
        pState: *mut float64_t,
    );
}
#[doc = " @brief Instance structure for the Q15 FIR lattice filter."]
#[repr(C)]
pub struct arm_fir_lattice_instance_q15 {
    #[doc = "< number of filter stages."]
    pub numStages: u16,
    #[doc = "< points to the state variable array. The array is of length numStages."]
    pub pState: *mut q15_t,
    #[doc = "< points to the coefficient array. The array is of length numStages."]
    pub pCoeffs: *const q15_t,
}
#[test]
fn bindgen_test_layout_arm_fir_lattice_instance_q15() {
    assert_eq!(
        ::core::mem::size_of::<arm_fir_lattice_instance_q15>(),
        24usize,
        concat!("Size of: ", stringify!(arm_fir_lattice_instance_q15))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_fir_lattice_instance_q15>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_fir_lattice_instance_q15))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_lattice_instance_q15>())).numStages as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_lattice_instance_q15),
            "::",
            stringify!(numStages)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_lattice_instance_q15>())).pState as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_lattice_instance_q15),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_lattice_instance_q15>())).pCoeffs as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_lattice_instance_q15),
            "::",
            stringify!(pCoeffs)
        )
    );
}
#[doc = " @brief Instance structure for the Q31 FIR lattice filter."]
#[repr(C)]
pub struct arm_fir_lattice_instance_q31 {
    #[doc = "< number of filter stages."]
    pub numStages: u16,
    #[doc = "< points to the state variable array. The array is of length numStages."]
    pub pState: *mut q31_t,
    #[doc = "< points to the coefficient array. The array is of length numStages."]
    pub pCoeffs: *const q31_t,
}
#[test]
fn bindgen_test_layout_arm_fir_lattice_instance_q31() {
    assert_eq!(
        ::core::mem::size_of::<arm_fir_lattice_instance_q31>(),
        24usize,
        concat!("Size of: ", stringify!(arm_fir_lattice_instance_q31))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_fir_lattice_instance_q31>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_fir_lattice_instance_q31))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_lattice_instance_q31>())).numStages as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_lattice_instance_q31),
            "::",
            stringify!(numStages)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_lattice_instance_q31>())).pState as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_lattice_instance_q31),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_lattice_instance_q31>())).pCoeffs as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_lattice_instance_q31),
            "::",
            stringify!(pCoeffs)
        )
    );
}
#[doc = " @brief Instance structure for the floating-point FIR lattice filter."]
#[repr(C)]
pub struct arm_fir_lattice_instance_f32 {
    #[doc = "< number of filter stages."]
    pub numStages: u16,
    #[doc = "< points to the state variable array. The array is of length numStages."]
    pub pState: *mut float32_t,
    #[doc = "< points to the coefficient array. The array is of length numStages."]
    pub pCoeffs: *const float32_t,
}
#[test]
fn bindgen_test_layout_arm_fir_lattice_instance_f32() {
    assert_eq!(
        ::core::mem::size_of::<arm_fir_lattice_instance_f32>(),
        24usize,
        concat!("Size of: ", stringify!(arm_fir_lattice_instance_f32))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_fir_lattice_instance_f32>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_fir_lattice_instance_f32))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_lattice_instance_f32>())).numStages as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_lattice_instance_f32),
            "::",
            stringify!(numStages)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_lattice_instance_f32>())).pState as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_lattice_instance_f32),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_lattice_instance_f32>())).pCoeffs as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_lattice_instance_f32),
            "::",
            stringify!(pCoeffs)
        )
    );
}
extern "C" {
    #[doc = " @brief Initialization function for the Q15 FIR lattice filter."]
    #[doc = " @param[in] S          points to an instance of the Q15 FIR lattice structure."]
    #[doc = " @param[in] numStages  number of filter stages."]
    #[doc = " @param[in] pCoeffs    points to the coefficient buffer.  The array is of length numStages."]
    #[doc = " @param[in] pState     points to the state buffer.  The array is of length numStages."]
    pub fn arm_fir_lattice_init_q15(
        S: *mut arm_fir_lattice_instance_q15,
        numStages: u16,
        pCoeffs: *const q15_t,
        pState: *mut q15_t,
    );
}
extern "C" {
    #[doc = " @brief Processing function for the Q15 FIR lattice filter."]
    #[doc = " @param[in]  S          points to an instance of the Q15 FIR lattice structure."]
    #[doc = " @param[in]  pSrc       points to the block of input data."]
    #[doc = " @param[out] pDst       points to the block of output data."]
    #[doc = " @param[in]  blockSize  number of samples to process."]
    pub fn arm_fir_lattice_q15(
        S: *const arm_fir_lattice_instance_q15,
        pSrc: *const q15_t,
        pDst: *mut q15_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Initialization function for the Q31 FIR lattice filter."]
    #[doc = " @param[in] S          points to an instance of the Q31 FIR lattice structure."]
    #[doc = " @param[in] numStages  number of filter stages."]
    #[doc = " @param[in] pCoeffs    points to the coefficient buffer.  The array is of length numStages."]
    #[doc = " @param[in] pState     points to the state buffer.   The array is of length numStages."]
    pub fn arm_fir_lattice_init_q31(
        S: *mut arm_fir_lattice_instance_q31,
        numStages: u16,
        pCoeffs: *const q31_t,
        pState: *mut q31_t,
    );
}
extern "C" {
    #[doc = " @brief Processing function for the Q31 FIR lattice filter."]
    #[doc = " @param[in]  S          points to an instance of the Q31 FIR lattice structure."]
    #[doc = " @param[in]  pSrc       points to the block of input data."]
    #[doc = " @param[out] pDst       points to the block of output data"]
    #[doc = " @param[in]  blockSize  number of samples to process."]
    pub fn arm_fir_lattice_q31(
        S: *const arm_fir_lattice_instance_q31,
        pSrc: *const q31_t,
        pDst: *mut q31_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Initialization function for the floating-point FIR lattice filter."]
    #[doc = " @param[in] S          points to an instance of the floating-point FIR lattice structure."]
    #[doc = " @param[in] numStages  number of filter stages."]
    #[doc = " @param[in] pCoeffs    points to the coefficient buffer.  The array is of length numStages."]
    #[doc = " @param[in] pState     points to the state buffer.  The array is of length numStages."]
    pub fn arm_fir_lattice_init_f32(
        S: *mut arm_fir_lattice_instance_f32,
        numStages: u16,
        pCoeffs: *const float32_t,
        pState: *mut float32_t,
    );
}
extern "C" {
    #[doc = " @brief Processing function for the floating-point FIR lattice filter."]
    #[doc = " @param[in]  S          points to an instance of the floating-point FIR lattice structure."]
    #[doc = " @param[in]  pSrc       points to the block of input data."]
    #[doc = " @param[out] pDst       points to the block of output data"]
    #[doc = " @param[in]  blockSize  number of samples to process."]
    pub fn arm_fir_lattice_f32(
        S: *const arm_fir_lattice_instance_f32,
        pSrc: *const float32_t,
        pDst: *mut float32_t,
        blockSize: u32,
    );
}
#[doc = " @brief Instance structure for the Q15 IIR lattice filter."]
#[repr(C)]
pub struct arm_iir_lattice_instance_q15 {
    #[doc = "< number of stages in the filter."]
    pub numStages: u16,
    #[doc = "< points to the state variable array. The array is of length numStages+blockSize."]
    pub pState: *mut q15_t,
    #[doc = "< points to the reflection coefficient array. The array is of length numStages."]
    pub pkCoeffs: *mut q15_t,
    #[doc = "< points to the ladder coefficient array. The array is of length numStages+1."]
    pub pvCoeffs: *mut q15_t,
}
#[test]
fn bindgen_test_layout_arm_iir_lattice_instance_q15() {
    assert_eq!(
        ::core::mem::size_of::<arm_iir_lattice_instance_q15>(),
        32usize,
        concat!("Size of: ", stringify!(arm_iir_lattice_instance_q15))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_iir_lattice_instance_q15>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_iir_lattice_instance_q15))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_iir_lattice_instance_q15>())).numStages as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_iir_lattice_instance_q15),
            "::",
            stringify!(numStages)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_iir_lattice_instance_q15>())).pState as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_iir_lattice_instance_q15),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_iir_lattice_instance_q15>())).pkCoeffs as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_iir_lattice_instance_q15),
            "::",
            stringify!(pkCoeffs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_iir_lattice_instance_q15>())).pvCoeffs as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_iir_lattice_instance_q15),
            "::",
            stringify!(pvCoeffs)
        )
    );
}
#[doc = " @brief Instance structure for the Q31 IIR lattice filter."]
#[repr(C)]
pub struct arm_iir_lattice_instance_q31 {
    #[doc = "< number of stages in the filter."]
    pub numStages: u16,
    #[doc = "< points to the state variable array. The array is of length numStages+blockSize."]
    pub pState: *mut q31_t,
    #[doc = "< points to the reflection coefficient array. The array is of length numStages."]
    pub pkCoeffs: *mut q31_t,
    #[doc = "< points to the ladder coefficient array. The array is of length numStages+1."]
    pub pvCoeffs: *mut q31_t,
}
#[test]
fn bindgen_test_layout_arm_iir_lattice_instance_q31() {
    assert_eq!(
        ::core::mem::size_of::<arm_iir_lattice_instance_q31>(),
        32usize,
        concat!("Size of: ", stringify!(arm_iir_lattice_instance_q31))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_iir_lattice_instance_q31>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_iir_lattice_instance_q31))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_iir_lattice_instance_q31>())).numStages as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_iir_lattice_instance_q31),
            "::",
            stringify!(numStages)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_iir_lattice_instance_q31>())).pState as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_iir_lattice_instance_q31),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_iir_lattice_instance_q31>())).pkCoeffs as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_iir_lattice_instance_q31),
            "::",
            stringify!(pkCoeffs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_iir_lattice_instance_q31>())).pvCoeffs as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_iir_lattice_instance_q31),
            "::",
            stringify!(pvCoeffs)
        )
    );
}
#[doc = " @brief Instance structure for the floating-point IIR lattice filter."]
#[repr(C)]
pub struct arm_iir_lattice_instance_f32 {
    #[doc = "< number of stages in the filter."]
    pub numStages: u16,
    #[doc = "< points to the state variable array. The array is of length numStages+blockSize."]
    pub pState: *mut float32_t,
    #[doc = "< points to the reflection coefficient array. The array is of length numStages."]
    pub pkCoeffs: *mut float32_t,
    #[doc = "< points to the ladder coefficient array. The array is of length numStages+1."]
    pub pvCoeffs: *mut float32_t,
}
#[test]
fn bindgen_test_layout_arm_iir_lattice_instance_f32() {
    assert_eq!(
        ::core::mem::size_of::<arm_iir_lattice_instance_f32>(),
        32usize,
        concat!("Size of: ", stringify!(arm_iir_lattice_instance_f32))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_iir_lattice_instance_f32>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_iir_lattice_instance_f32))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_iir_lattice_instance_f32>())).numStages as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_iir_lattice_instance_f32),
            "::",
            stringify!(numStages)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_iir_lattice_instance_f32>())).pState as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_iir_lattice_instance_f32),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_iir_lattice_instance_f32>())).pkCoeffs as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_iir_lattice_instance_f32),
            "::",
            stringify!(pkCoeffs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_iir_lattice_instance_f32>())).pvCoeffs as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_iir_lattice_instance_f32),
            "::",
            stringify!(pvCoeffs)
        )
    );
}
extern "C" {
    #[doc = " @brief Processing function for the floating-point IIR lattice filter."]
    #[doc = " @param[in]  S          points to an instance of the floating-point IIR lattice structure."]
    #[doc = " @param[in]  pSrc       points to the block of input data."]
    #[doc = " @param[out] pDst       points to the block of output data."]
    #[doc = " @param[in]  blockSize  number of samples to process."]
    pub fn arm_iir_lattice_f32(
        S: *const arm_iir_lattice_instance_f32,
        pSrc: *const float32_t,
        pDst: *mut float32_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Initialization function for the floating-point IIR lattice filter."]
    #[doc = " @param[in] S          points to an instance of the floating-point IIR lattice structure."]
    #[doc = " @param[in] numStages  number of stages in the filter."]
    #[doc = " @param[in] pkCoeffs   points to the reflection coefficient buffer.  The array is of length numStages."]
    #[doc = " @param[in] pvCoeffs   points to the ladder coefficient buffer.  The array is of length numStages+1."]
    #[doc = " @param[in] pState     points to the state buffer.  The array is of length numStages+blockSize-1."]
    #[doc = " @param[in] blockSize  number of samples to process."]
    pub fn arm_iir_lattice_init_f32(
        S: *mut arm_iir_lattice_instance_f32,
        numStages: u16,
        pkCoeffs: *mut float32_t,
        pvCoeffs: *mut float32_t,
        pState: *mut float32_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Processing function for the Q31 IIR lattice filter."]
    #[doc = " @param[in]  S          points to an instance of the Q31 IIR lattice structure."]
    #[doc = " @param[in]  pSrc       points to the block of input data."]
    #[doc = " @param[out] pDst       points to the block of output data."]
    #[doc = " @param[in]  blockSize  number of samples to process."]
    pub fn arm_iir_lattice_q31(
        S: *const arm_iir_lattice_instance_q31,
        pSrc: *const q31_t,
        pDst: *mut q31_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Initialization function for the Q31 IIR lattice filter."]
    #[doc = " @param[in] S          points to an instance of the Q31 IIR lattice structure."]
    #[doc = " @param[in] numStages  number of stages in the filter."]
    #[doc = " @param[in] pkCoeffs   points to the reflection coefficient buffer.  The array is of length numStages."]
    #[doc = " @param[in] pvCoeffs   points to the ladder coefficient buffer.  The array is of length numStages+1."]
    #[doc = " @param[in] pState     points to the state buffer.  The array is of length numStages+blockSize."]
    #[doc = " @param[in] blockSize  number of samples to process."]
    pub fn arm_iir_lattice_init_q31(
        S: *mut arm_iir_lattice_instance_q31,
        numStages: u16,
        pkCoeffs: *mut q31_t,
        pvCoeffs: *mut q31_t,
        pState: *mut q31_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Processing function for the Q15 IIR lattice filter."]
    #[doc = " @param[in]  S          points to an instance of the Q15 IIR lattice structure."]
    #[doc = " @param[in]  pSrc       points to the block of input data."]
    #[doc = " @param[out] pDst       points to the block of output data."]
    #[doc = " @param[in]  blockSize  number of samples to process."]
    pub fn arm_iir_lattice_q15(
        S: *const arm_iir_lattice_instance_q15,
        pSrc: *const q15_t,
        pDst: *mut q15_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Initialization function for the Q15 IIR lattice filter."]
    #[doc = " @param[in] S          points to an instance of the fixed-point Q15 IIR lattice structure."]
    #[doc = " @param[in] numStages  number of stages in the filter."]
    #[doc = " @param[in] pkCoeffs   points to reflection coefficient buffer.  The array is of length numStages."]
    #[doc = " @param[in] pvCoeffs   points to ladder coefficient buffer.  The array is of length numStages+1."]
    #[doc = " @param[in] pState     points to state buffer.  The array is of length numStages+blockSize."]
    #[doc = " @param[in] blockSize  number of samples to process per call."]
    pub fn arm_iir_lattice_init_q15(
        S: *mut arm_iir_lattice_instance_q15,
        numStages: u16,
        pkCoeffs: *mut q15_t,
        pvCoeffs: *mut q15_t,
        pState: *mut q15_t,
        blockSize: u32,
    );
}
#[doc = " @brief Instance structure for the floating-point LMS filter."]
#[repr(C)]
pub struct arm_lms_instance_f32 {
    #[doc = "< number of coefficients in the filter."]
    pub numTaps: u16,
    #[doc = "< points to the state variable array. The array is of length numTaps+blockSize-1."]
    pub pState: *mut float32_t,
    #[doc = "< points to the coefficient array. The array is of length numTaps."]
    pub pCoeffs: *mut float32_t,
    #[doc = "< step size that controls filter coefficient updates."]
    pub mu: float32_t,
}
#[test]
fn bindgen_test_layout_arm_lms_instance_f32() {
    assert_eq!(
        ::core::mem::size_of::<arm_lms_instance_f32>(),
        32usize,
        concat!("Size of: ", stringify!(arm_lms_instance_f32))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_lms_instance_f32>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_lms_instance_f32))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_lms_instance_f32>())).numTaps as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_instance_f32),
            "::",
            stringify!(numTaps)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_lms_instance_f32>())).pState as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_instance_f32),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_lms_instance_f32>())).pCoeffs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_instance_f32),
            "::",
            stringify!(pCoeffs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_lms_instance_f32>())).mu as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_instance_f32),
            "::",
            stringify!(mu)
        )
    );
}
extern "C" {
    #[doc = " @brief Processing function for floating-point LMS filter."]
    #[doc = " @param[in]  S          points to an instance of the floating-point LMS filter structure."]
    #[doc = " @param[in]  pSrc       points to the block of input data."]
    #[doc = " @param[in]  pRef       points to the block of reference data."]
    #[doc = " @param[out] pOut       points to the block of output data."]
    #[doc = " @param[out] pErr       points to the block of error data."]
    #[doc = " @param[in]  blockSize  number of samples to process."]
    pub fn arm_lms_f32(
        S: *const arm_lms_instance_f32,
        pSrc: *const float32_t,
        pRef: *mut float32_t,
        pOut: *mut float32_t,
        pErr: *mut float32_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Initialization function for floating-point LMS filter."]
    #[doc = " @param[in] S          points to an instance of the floating-point LMS filter structure."]
    #[doc = " @param[in] numTaps    number of filter coefficients."]
    #[doc = " @param[in] pCoeffs    points to the coefficient buffer."]
    #[doc = " @param[in] pState     points to state buffer."]
    #[doc = " @param[in] mu         step size that controls filter coefficient updates."]
    #[doc = " @param[in] blockSize  number of samples to process."]
    pub fn arm_lms_init_f32(
        S: *mut arm_lms_instance_f32,
        numTaps: u16,
        pCoeffs: *mut float32_t,
        pState: *mut float32_t,
        mu: float32_t,
        blockSize: u32,
    );
}
#[doc = " @brief Instance structure for the Q15 LMS filter."]
#[repr(C)]
pub struct arm_lms_instance_q15 {
    #[doc = "< number of coefficients in the filter."]
    pub numTaps: u16,
    #[doc = "< points to the state variable array. The array is of length numTaps+blockSize-1."]
    pub pState: *mut q15_t,
    #[doc = "< points to the coefficient array. The array is of length numTaps."]
    pub pCoeffs: *mut q15_t,
    #[doc = "< step size that controls filter coefficient updates."]
    pub mu: q15_t,
    #[doc = "< bit shift applied to coefficients."]
    pub postShift: u32,
}
#[test]
fn bindgen_test_layout_arm_lms_instance_q15() {
    assert_eq!(
        ::core::mem::size_of::<arm_lms_instance_q15>(),
        32usize,
        concat!("Size of: ", stringify!(arm_lms_instance_q15))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_lms_instance_q15>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_lms_instance_q15))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_lms_instance_q15>())).numTaps as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_instance_q15),
            "::",
            stringify!(numTaps)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_lms_instance_q15>())).pState as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_instance_q15),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_lms_instance_q15>())).pCoeffs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_instance_q15),
            "::",
            stringify!(pCoeffs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_lms_instance_q15>())).mu as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_instance_q15),
            "::",
            stringify!(mu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_lms_instance_q15>())).postShift as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_instance_q15),
            "::",
            stringify!(postShift)
        )
    );
}
extern "C" {
    #[doc = " @brief Initialization function for the Q15 LMS filter."]
    #[doc = " @param[in] S          points to an instance of the Q15 LMS filter structure."]
    #[doc = " @param[in] numTaps    number of filter coefficients."]
    #[doc = " @param[in] pCoeffs    points to the coefficient buffer."]
    #[doc = " @param[in] pState     points to the state buffer."]
    #[doc = " @param[in] mu         step size that controls filter coefficient updates."]
    #[doc = " @param[in] blockSize  number of samples to process."]
    #[doc = " @param[in] postShift  bit shift applied to coefficients."]
    pub fn arm_lms_init_q15(
        S: *mut arm_lms_instance_q15,
        numTaps: u16,
        pCoeffs: *mut q15_t,
        pState: *mut q15_t,
        mu: q15_t,
        blockSize: u32,
        postShift: u32,
    );
}
extern "C" {
    #[doc = " @brief Processing function for Q15 LMS filter."]
    #[doc = " @param[in]  S          points to an instance of the Q15 LMS filter structure."]
    #[doc = " @param[in]  pSrc       points to the block of input data."]
    #[doc = " @param[in]  pRef       points to the block of reference data."]
    #[doc = " @param[out] pOut       points to the block of output data."]
    #[doc = " @param[out] pErr       points to the block of error data."]
    #[doc = " @param[in]  blockSize  number of samples to process."]
    pub fn arm_lms_q15(
        S: *const arm_lms_instance_q15,
        pSrc: *const q15_t,
        pRef: *mut q15_t,
        pOut: *mut q15_t,
        pErr: *mut q15_t,
        blockSize: u32,
    );
}
#[doc = " @brief Instance structure for the Q31 LMS filter."]
#[repr(C)]
pub struct arm_lms_instance_q31 {
    #[doc = "< number of coefficients in the filter."]
    pub numTaps: u16,
    #[doc = "< points to the state variable array. The array is of length numTaps+blockSize-1."]
    pub pState: *mut q31_t,
    #[doc = "< points to the coefficient array. The array is of length numTaps."]
    pub pCoeffs: *mut q31_t,
    #[doc = "< step size that controls filter coefficient updates."]
    pub mu: q31_t,
    #[doc = "< bit shift applied to coefficients."]
    pub postShift: u32,
}
#[test]
fn bindgen_test_layout_arm_lms_instance_q31() {
    assert_eq!(
        ::core::mem::size_of::<arm_lms_instance_q31>(),
        32usize,
        concat!("Size of: ", stringify!(arm_lms_instance_q31))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_lms_instance_q31>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_lms_instance_q31))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_lms_instance_q31>())).numTaps as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_instance_q31),
            "::",
            stringify!(numTaps)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_lms_instance_q31>())).pState as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_instance_q31),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_lms_instance_q31>())).pCoeffs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_instance_q31),
            "::",
            stringify!(pCoeffs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_lms_instance_q31>())).mu as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_instance_q31),
            "::",
            stringify!(mu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_lms_instance_q31>())).postShift as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_instance_q31),
            "::",
            stringify!(postShift)
        )
    );
}
extern "C" {
    #[doc = " @brief Processing function for Q31 LMS filter."]
    #[doc = " @param[in]  S          points to an instance of the Q15 LMS filter structure."]
    #[doc = " @param[in]  pSrc       points to the block of input data."]
    #[doc = " @param[in]  pRef       points to the block of reference data."]
    #[doc = " @param[out] pOut       points to the block of output data."]
    #[doc = " @param[out] pErr       points to the block of error data."]
    #[doc = " @param[in]  blockSize  number of samples to process."]
    pub fn arm_lms_q31(
        S: *const arm_lms_instance_q31,
        pSrc: *const q31_t,
        pRef: *mut q31_t,
        pOut: *mut q31_t,
        pErr: *mut q31_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Initialization function for Q31 LMS filter."]
    #[doc = " @param[in] S          points to an instance of the Q31 LMS filter structure."]
    #[doc = " @param[in] numTaps    number of filter coefficients."]
    #[doc = " @param[in] pCoeffs    points to coefficient buffer."]
    #[doc = " @param[in] pState     points to state buffer."]
    #[doc = " @param[in] mu         step size that controls filter coefficient updates."]
    #[doc = " @param[in] blockSize  number of samples to process."]
    #[doc = " @param[in] postShift  bit shift applied to coefficients."]
    pub fn arm_lms_init_q31(
        S: *mut arm_lms_instance_q31,
        numTaps: u16,
        pCoeffs: *mut q31_t,
        pState: *mut q31_t,
        mu: q31_t,
        blockSize: u32,
        postShift: u32,
    );
}
#[doc = " @brief Instance structure for the floating-point normalized LMS filter."]
#[repr(C)]
pub struct arm_lms_norm_instance_f32 {
    #[doc = "< number of coefficients in the filter."]
    pub numTaps: u16,
    #[doc = "< points to the state variable array. The array is of length numTaps+blockSize-1."]
    pub pState: *mut float32_t,
    #[doc = "< points to the coefficient array. The array is of length numTaps."]
    pub pCoeffs: *mut float32_t,
    #[doc = "< step size that control filter coefficient updates."]
    pub mu: float32_t,
    #[doc = "< saves previous frame energy."]
    pub energy: float32_t,
    #[doc = "< saves previous input sample."]
    pub x0: float32_t,
}
#[test]
fn bindgen_test_layout_arm_lms_norm_instance_f32() {
    assert_eq!(
        ::core::mem::size_of::<arm_lms_norm_instance_f32>(),
        40usize,
        concat!("Size of: ", stringify!(arm_lms_norm_instance_f32))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_lms_norm_instance_f32>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_lms_norm_instance_f32))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_lms_norm_instance_f32>())).numTaps as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_norm_instance_f32),
            "::",
            stringify!(numTaps)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_lms_norm_instance_f32>())).pState as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_norm_instance_f32),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_lms_norm_instance_f32>())).pCoeffs as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_norm_instance_f32),
            "::",
            stringify!(pCoeffs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_lms_norm_instance_f32>())).mu as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_norm_instance_f32),
            "::",
            stringify!(mu)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_lms_norm_instance_f32>())).energy as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_norm_instance_f32),
            "::",
            stringify!(energy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_lms_norm_instance_f32>())).x0 as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_norm_instance_f32),
            "::",
            stringify!(x0)
        )
    );
}
extern "C" {
    #[doc = " @brief Processing function for floating-point normalized LMS filter."]
    #[doc = " @param[in]  S          points to an instance of the floating-point normalized LMS filter structure."]
    #[doc = " @param[in]  pSrc       points to the block of input data."]
    #[doc = " @param[in]  pRef       points to the block of reference data."]
    #[doc = " @param[out] pOut       points to the block of output data."]
    #[doc = " @param[out] pErr       points to the block of error data."]
    #[doc = " @param[in]  blockSize  number of samples to process."]
    pub fn arm_lms_norm_f32(
        S: *mut arm_lms_norm_instance_f32,
        pSrc: *const float32_t,
        pRef: *mut float32_t,
        pOut: *mut float32_t,
        pErr: *mut float32_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Initialization function for floating-point normalized LMS filter."]
    #[doc = " @param[in] S          points to an instance of the floating-point LMS filter structure."]
    #[doc = " @param[in] numTaps    number of filter coefficients."]
    #[doc = " @param[in] pCoeffs    points to coefficient buffer."]
    #[doc = " @param[in] pState     points to state buffer."]
    #[doc = " @param[in] mu         step size that controls filter coefficient updates."]
    #[doc = " @param[in] blockSize  number of samples to process."]
    pub fn arm_lms_norm_init_f32(
        S: *mut arm_lms_norm_instance_f32,
        numTaps: u16,
        pCoeffs: *mut float32_t,
        pState: *mut float32_t,
        mu: float32_t,
        blockSize: u32,
    );
}
#[doc = " @brief Instance structure for the Q31 normalized LMS filter."]
#[repr(C)]
pub struct arm_lms_norm_instance_q31 {
    #[doc = "< number of coefficients in the filter."]
    pub numTaps: u16,
    #[doc = "< points to the state variable array. The array is of length numTaps+blockSize-1."]
    pub pState: *mut q31_t,
    #[doc = "< points to the coefficient array. The array is of length numTaps."]
    pub pCoeffs: *mut q31_t,
    #[doc = "< step size that controls filter coefficient updates."]
    pub mu: q31_t,
    #[doc = "< bit shift applied to coefficients."]
    pub postShift: u8,
    #[doc = "< points to the reciprocal initial value table."]
    pub recipTable: *const q31_t,
    #[doc = "< saves previous frame energy."]
    pub energy: q31_t,
    #[doc = "< saves previous input sample."]
    pub x0: q31_t,
}
#[test]
fn bindgen_test_layout_arm_lms_norm_instance_q31() {
    assert_eq!(
        ::core::mem::size_of::<arm_lms_norm_instance_q31>(),
        48usize,
        concat!("Size of: ", stringify!(arm_lms_norm_instance_q31))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_lms_norm_instance_q31>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_lms_norm_instance_q31))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_lms_norm_instance_q31>())).numTaps as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_norm_instance_q31),
            "::",
            stringify!(numTaps)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_lms_norm_instance_q31>())).pState as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_norm_instance_q31),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_lms_norm_instance_q31>())).pCoeffs as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_norm_instance_q31),
            "::",
            stringify!(pCoeffs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_lms_norm_instance_q31>())).mu as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_norm_instance_q31),
            "::",
            stringify!(mu)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_lms_norm_instance_q31>())).postShift as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_norm_instance_q31),
            "::",
            stringify!(postShift)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_lms_norm_instance_q31>())).recipTable as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_norm_instance_q31),
            "::",
            stringify!(recipTable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_lms_norm_instance_q31>())).energy as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_norm_instance_q31),
            "::",
            stringify!(energy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_lms_norm_instance_q31>())).x0 as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_norm_instance_q31),
            "::",
            stringify!(x0)
        )
    );
}
extern "C" {
    #[doc = " @brief Processing function for Q31 normalized LMS filter."]
    #[doc = " @param[in]  S          points to an instance of the Q31 normalized LMS filter structure."]
    #[doc = " @param[in]  pSrc       points to the block of input data."]
    #[doc = " @param[in]  pRef       points to the block of reference data."]
    #[doc = " @param[out] pOut       points to the block of output data."]
    #[doc = " @param[out] pErr       points to the block of error data."]
    #[doc = " @param[in]  blockSize  number of samples to process."]
    pub fn arm_lms_norm_q31(
        S: *mut arm_lms_norm_instance_q31,
        pSrc: *const q31_t,
        pRef: *mut q31_t,
        pOut: *mut q31_t,
        pErr: *mut q31_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Initialization function for Q31 normalized LMS filter."]
    #[doc = " @param[in] S          points to an instance of the Q31 normalized LMS filter structure."]
    #[doc = " @param[in] numTaps    number of filter coefficients."]
    #[doc = " @param[in] pCoeffs    points to coefficient buffer."]
    #[doc = " @param[in] pState     points to state buffer."]
    #[doc = " @param[in] mu         step size that controls filter coefficient updates."]
    #[doc = " @param[in] blockSize  number of samples to process."]
    #[doc = " @param[in] postShift  bit shift applied to coefficients."]
    pub fn arm_lms_norm_init_q31(
        S: *mut arm_lms_norm_instance_q31,
        numTaps: u16,
        pCoeffs: *mut q31_t,
        pState: *mut q31_t,
        mu: q31_t,
        blockSize: u32,
        postShift: u8,
    );
}
#[doc = " @brief Instance structure for the Q15 normalized LMS filter."]
#[repr(C)]
pub struct arm_lms_norm_instance_q15 {
    #[doc = "< Number of coefficients in the filter."]
    pub numTaps: u16,
    #[doc = "< points to the state variable array. The array is of length numTaps+blockSize-1."]
    pub pState: *mut q15_t,
    #[doc = "< points to the coefficient array. The array is of length numTaps."]
    pub pCoeffs: *mut q15_t,
    #[doc = "< step size that controls filter coefficient updates."]
    pub mu: q15_t,
    #[doc = "< bit shift applied to coefficients."]
    pub postShift: u8,
    #[doc = "< Points to the reciprocal initial value table."]
    pub recipTable: *const q15_t,
    #[doc = "< saves previous frame energy."]
    pub energy: q15_t,
    #[doc = "< saves previous input sample."]
    pub x0: q15_t,
}
#[test]
fn bindgen_test_layout_arm_lms_norm_instance_q15() {
    assert_eq!(
        ::core::mem::size_of::<arm_lms_norm_instance_q15>(),
        48usize,
        concat!("Size of: ", stringify!(arm_lms_norm_instance_q15))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_lms_norm_instance_q15>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_lms_norm_instance_q15))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_lms_norm_instance_q15>())).numTaps as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_norm_instance_q15),
            "::",
            stringify!(numTaps)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_lms_norm_instance_q15>())).pState as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_norm_instance_q15),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_lms_norm_instance_q15>())).pCoeffs as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_norm_instance_q15),
            "::",
            stringify!(pCoeffs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_lms_norm_instance_q15>())).mu as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_norm_instance_q15),
            "::",
            stringify!(mu)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_lms_norm_instance_q15>())).postShift as *const _ as usize
        },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_norm_instance_q15),
            "::",
            stringify!(postShift)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_lms_norm_instance_q15>())).recipTable as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_norm_instance_q15),
            "::",
            stringify!(recipTable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_lms_norm_instance_q15>())).energy as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_norm_instance_q15),
            "::",
            stringify!(energy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arm_lms_norm_instance_q15>())).x0 as *const _ as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_lms_norm_instance_q15),
            "::",
            stringify!(x0)
        )
    );
}
extern "C" {
    #[doc = " @brief Processing function for Q15 normalized LMS filter."]
    #[doc = " @param[in]  S          points to an instance of the Q15 normalized LMS filter structure."]
    #[doc = " @param[in]  pSrc       points to the block of input data."]
    #[doc = " @param[in]  pRef       points to the block of reference data."]
    #[doc = " @param[out] pOut       points to the block of output data."]
    #[doc = " @param[out] pErr       points to the block of error data."]
    #[doc = " @param[in]  blockSize  number of samples to process."]
    pub fn arm_lms_norm_q15(
        S: *mut arm_lms_norm_instance_q15,
        pSrc: *const q15_t,
        pRef: *mut q15_t,
        pOut: *mut q15_t,
        pErr: *mut q15_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Initialization function for Q15 normalized LMS filter."]
    #[doc = " @param[in] S          points to an instance of the Q15 normalized LMS filter structure."]
    #[doc = " @param[in] numTaps    number of filter coefficients."]
    #[doc = " @param[in] pCoeffs    points to coefficient buffer."]
    #[doc = " @param[in] pState     points to state buffer."]
    #[doc = " @param[in] mu         step size that controls filter coefficient updates."]
    #[doc = " @param[in] blockSize  number of samples to process."]
    #[doc = " @param[in] postShift  bit shift applied to coefficients."]
    pub fn arm_lms_norm_init_q15(
        S: *mut arm_lms_norm_instance_q15,
        numTaps: u16,
        pCoeffs: *mut q15_t,
        pState: *mut q15_t,
        mu: q15_t,
        blockSize: u32,
        postShift: u8,
    );
}
extern "C" {
    #[doc = " @brief Correlation of floating-point sequences."]
    #[doc = " @param[in]  pSrcA    points to the first input sequence."]
    #[doc = " @param[in]  srcALen  length of the first input sequence."]
    #[doc = " @param[in]  pSrcB    points to the second input sequence."]
    #[doc = " @param[in]  srcBLen  length of the second input sequence."]
    #[doc = " @param[out] pDst     points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1."]
    pub fn arm_correlate_f32(
        pSrcA: *const float32_t,
        srcALen: u32,
        pSrcB: *const float32_t,
        srcBLen: u32,
        pDst: *mut float32_t,
    );
}
extern "C" {
    #[doc = "@brief Correlation of Q15 sequences"]
    #[doc = "@param[in]  pSrcA     points to the first input sequence"]
    #[doc = "@param[in]  srcALen   length of the first input sequence"]
    #[doc = "@param[in]  pSrcB     points to the second input sequence"]
    #[doc = "@param[in]  srcBLen   length of the second input sequence"]
    #[doc = "@param[out] pDst      points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1."]
    #[doc = "@param[in]  pScratch  points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2."]
    pub fn arm_correlate_opt_q15(
        pSrcA: *const q15_t,
        srcALen: u32,
        pSrcB: *const q15_t,
        srcBLen: u32,
        pDst: *mut q15_t,
        pScratch: *mut q15_t,
    );
}
extern "C" {
    #[doc = "@brief Correlation of Q15 sequences."]
    #[doc = "@param[in]  pSrcA    points to the first input sequence"]
    #[doc = "@param[in]  srcALen  length of the first input sequence"]
    #[doc = "@param[in]  pSrcB    points to the second input sequence"]
    #[doc = "@param[in]  srcBLen  length of the second input sequence"]
    #[doc = "@param[out] pDst     points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1."]
    pub fn arm_correlate_q15(
        pSrcA: *const q15_t,
        srcALen: u32,
        pSrcB: *const q15_t,
        srcBLen: u32,
        pDst: *mut q15_t,
    );
}
extern "C" {
    #[doc = "@brief         Correlation of Q15 sequences (fast version)."]
    #[doc = "@param[in]     pSrcA      points to the first input sequence"]
    #[doc = "@param[in]     srcALen    length of the first input sequence"]
    #[doc = "@param[in]     pSrcB      points to the second input sequence"]
    #[doc = "@param[in]     srcBLen    length of the second input sequence"]
    #[doc = "@param[out]    pDst       points to the location where the output result is written.  Length 2 * max(srcALen, srcBLen) - 1."]
    #[doc = "@return        none"]
    pub fn arm_correlate_fast_q15(
        pSrcA: *const q15_t,
        srcALen: u32,
        pSrcB: *const q15_t,
        srcBLen: u32,
        pDst: *mut q15_t,
    );
}
extern "C" {
    #[doc = "@brief Correlation of Q15 sequences (fast version)."]
    #[doc = "@param[in]  pSrcA     points to the first input sequence."]
    #[doc = "@param[in]  srcALen   length of the first input sequence."]
    #[doc = "@param[in]  pSrcB     points to the second input sequence."]
    #[doc = "@param[in]  srcBLen   length of the second input sequence."]
    #[doc = "@param[out] pDst      points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1."]
    #[doc = "@param[in]  pScratch  points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2."]
    pub fn arm_correlate_fast_opt_q15(
        pSrcA: *const q15_t,
        srcALen: u32,
        pSrcB: *const q15_t,
        srcBLen: u32,
        pDst: *mut q15_t,
        pScratch: *mut q15_t,
    );
}
extern "C" {
    #[doc = " @brief Correlation of Q31 sequences."]
    #[doc = " @param[in]  pSrcA    points to the first input sequence."]
    #[doc = " @param[in]  srcALen  length of the first input sequence."]
    #[doc = " @param[in]  pSrcB    points to the second input sequence."]
    #[doc = " @param[in]  srcBLen  length of the second input sequence."]
    #[doc = " @param[out] pDst     points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1."]
    pub fn arm_correlate_q31(
        pSrcA: *const q31_t,
        srcALen: u32,
        pSrcB: *const q31_t,
        srcBLen: u32,
        pDst: *mut q31_t,
    );
}
extern "C" {
    #[doc = "@brief Correlation of Q31 sequences (fast version)."]
    #[doc = "@param[in]  pSrcA    points to the first input sequence"]
    #[doc = "@param[in]  srcALen  length of the first input sequence"]
    #[doc = "@param[in]  pSrcB    points to the second input sequence"]
    #[doc = "@param[in]  srcBLen  length of the second input sequence"]
    #[doc = "@param[out] pDst     points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1."]
    pub fn arm_correlate_fast_q31(
        pSrcA: *const q31_t,
        srcALen: u32,
        pSrcB: *const q31_t,
        srcBLen: u32,
        pDst: *mut q31_t,
    );
}
extern "C" {
    #[doc = " @brief Correlation of Q7 sequences."]
    #[doc = " @param[in]  pSrcA      points to the first input sequence."]
    #[doc = " @param[in]  srcALen    length of the first input sequence."]
    #[doc = " @param[in]  pSrcB      points to the second input sequence."]
    #[doc = " @param[in]  srcBLen    length of the second input sequence."]
    #[doc = " @param[out] pDst       points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1."]
    #[doc = " @param[in]  pScratch1  points to scratch buffer(of type q15_t) of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2."]
    #[doc = " @param[in]  pScratch2  points to scratch buffer (of type q15_t) of size min(srcALen, srcBLen)."]
    pub fn arm_correlate_opt_q7(
        pSrcA: *const q7_t,
        srcALen: u32,
        pSrcB: *const q7_t,
        srcBLen: u32,
        pDst: *mut q7_t,
        pScratch1: *mut q15_t,
        pScratch2: *mut q15_t,
    );
}
extern "C" {
    #[doc = " @brief Correlation of Q7 sequences."]
    #[doc = " @param[in]  pSrcA    points to the first input sequence."]
    #[doc = " @param[in]  srcALen  length of the first input sequence."]
    #[doc = " @param[in]  pSrcB    points to the second input sequence."]
    #[doc = " @param[in]  srcBLen  length of the second input sequence."]
    #[doc = " @param[out] pDst     points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1."]
    pub fn arm_correlate_q7(
        pSrcA: *const q7_t,
        srcALen: u32,
        pSrcB: *const q7_t,
        srcBLen: u32,
        pDst: *mut q7_t,
    );
}
#[doc = " @brief Instance structure for the floating-point sparse FIR filter."]
#[repr(C)]
pub struct arm_fir_sparse_instance_f32 {
    #[doc = "< number of coefficients in the filter."]
    pub numTaps: u16,
    #[doc = "< state buffer index.  Points to the oldest sample in the state buffer."]
    pub stateIndex: u16,
    #[doc = "< points to the state buffer array. The array is of length maxDelay+blockSize-1."]
    pub pState: *mut float32_t,
    #[doc = "< points to the coefficient array. The array is of length numTaps."]
    pub pCoeffs: *const float32_t,
    #[doc = "< maximum offset specified by the pTapDelay array."]
    pub maxDelay: u16,
    #[doc = "< points to the array of delay values.  The array is of length numTaps."]
    pub pTapDelay: *mut i32,
}
#[test]
fn bindgen_test_layout_arm_fir_sparse_instance_f32() {
    assert_eq!(
        ::core::mem::size_of::<arm_fir_sparse_instance_f32>(),
        40usize,
        concat!("Size of: ", stringify!(arm_fir_sparse_instance_f32))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_fir_sparse_instance_f32>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_fir_sparse_instance_f32))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_sparse_instance_f32>())).numTaps as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_sparse_instance_f32),
            "::",
            stringify!(numTaps)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_sparse_instance_f32>())).stateIndex as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_sparse_instance_f32),
            "::",
            stringify!(stateIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_sparse_instance_f32>())).pState as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_sparse_instance_f32),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_sparse_instance_f32>())).pCoeffs as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_sparse_instance_f32),
            "::",
            stringify!(pCoeffs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_sparse_instance_f32>())).maxDelay as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_sparse_instance_f32),
            "::",
            stringify!(maxDelay)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_sparse_instance_f32>())).pTapDelay as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_sparse_instance_f32),
            "::",
            stringify!(pTapDelay)
        )
    );
}
#[doc = " @brief Instance structure for the Q31 sparse FIR filter."]
#[repr(C)]
pub struct arm_fir_sparse_instance_q31 {
    #[doc = "< number of coefficients in the filter."]
    pub numTaps: u16,
    #[doc = "< state buffer index.  Points to the oldest sample in the state buffer."]
    pub stateIndex: u16,
    #[doc = "< points to the state buffer array. The array is of length maxDelay+blockSize-1."]
    pub pState: *mut q31_t,
    #[doc = "< points to the coefficient array. The array is of length numTaps."]
    pub pCoeffs: *const q31_t,
    #[doc = "< maximum offset specified by the pTapDelay array."]
    pub maxDelay: u16,
    #[doc = "< points to the array of delay values.  The array is of length numTaps."]
    pub pTapDelay: *mut i32,
}
#[test]
fn bindgen_test_layout_arm_fir_sparse_instance_q31() {
    assert_eq!(
        ::core::mem::size_of::<arm_fir_sparse_instance_q31>(),
        40usize,
        concat!("Size of: ", stringify!(arm_fir_sparse_instance_q31))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_fir_sparse_instance_q31>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_fir_sparse_instance_q31))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_sparse_instance_q31>())).numTaps as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_sparse_instance_q31),
            "::",
            stringify!(numTaps)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_sparse_instance_q31>())).stateIndex as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_sparse_instance_q31),
            "::",
            stringify!(stateIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_sparse_instance_q31>())).pState as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_sparse_instance_q31),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_sparse_instance_q31>())).pCoeffs as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_sparse_instance_q31),
            "::",
            stringify!(pCoeffs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_sparse_instance_q31>())).maxDelay as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_sparse_instance_q31),
            "::",
            stringify!(maxDelay)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_sparse_instance_q31>())).pTapDelay as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_sparse_instance_q31),
            "::",
            stringify!(pTapDelay)
        )
    );
}
#[doc = " @brief Instance structure for the Q15 sparse FIR filter."]
#[repr(C)]
pub struct arm_fir_sparse_instance_q15 {
    #[doc = "< number of coefficients in the filter."]
    pub numTaps: u16,
    #[doc = "< state buffer index.  Points to the oldest sample in the state buffer."]
    pub stateIndex: u16,
    #[doc = "< points to the state buffer array. The array is of length maxDelay+blockSize-1."]
    pub pState: *mut q15_t,
    #[doc = "< points to the coefficient array. The array is of length numTaps."]
    pub pCoeffs: *const q15_t,
    #[doc = "< maximum offset specified by the pTapDelay array."]
    pub maxDelay: u16,
    #[doc = "< points to the array of delay values.  The array is of length numTaps."]
    pub pTapDelay: *mut i32,
}
#[test]
fn bindgen_test_layout_arm_fir_sparse_instance_q15() {
    assert_eq!(
        ::core::mem::size_of::<arm_fir_sparse_instance_q15>(),
        40usize,
        concat!("Size of: ", stringify!(arm_fir_sparse_instance_q15))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_fir_sparse_instance_q15>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_fir_sparse_instance_q15))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_sparse_instance_q15>())).numTaps as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_sparse_instance_q15),
            "::",
            stringify!(numTaps)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_sparse_instance_q15>())).stateIndex as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_sparse_instance_q15),
            "::",
            stringify!(stateIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_sparse_instance_q15>())).pState as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_sparse_instance_q15),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_sparse_instance_q15>())).pCoeffs as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_sparse_instance_q15),
            "::",
            stringify!(pCoeffs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_sparse_instance_q15>())).maxDelay as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_sparse_instance_q15),
            "::",
            stringify!(maxDelay)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_sparse_instance_q15>())).pTapDelay as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_sparse_instance_q15),
            "::",
            stringify!(pTapDelay)
        )
    );
}
#[doc = " @brief Instance structure for the Q7 sparse FIR filter."]
#[repr(C)]
pub struct arm_fir_sparse_instance_q7 {
    #[doc = "< number of coefficients in the filter."]
    pub numTaps: u16,
    #[doc = "< state buffer index.  Points to the oldest sample in the state buffer."]
    pub stateIndex: u16,
    #[doc = "< points to the state buffer array. The array is of length maxDelay+blockSize-1."]
    pub pState: *mut q7_t,
    #[doc = "< points to the coefficient array. The array is of length numTaps."]
    pub pCoeffs: *const q7_t,
    #[doc = "< maximum offset specified by the pTapDelay array."]
    pub maxDelay: u16,
    #[doc = "< points to the array of delay values.  The array is of length numTaps."]
    pub pTapDelay: *mut i32,
}
#[test]
fn bindgen_test_layout_arm_fir_sparse_instance_q7() {
    assert_eq!(
        ::core::mem::size_of::<arm_fir_sparse_instance_q7>(),
        40usize,
        concat!("Size of: ", stringify!(arm_fir_sparse_instance_q7))
    );
    assert_eq!(
        ::core::mem::align_of::<arm_fir_sparse_instance_q7>(),
        8usize,
        concat!("Alignment of ", stringify!(arm_fir_sparse_instance_q7))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_sparse_instance_q7>())).numTaps as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_sparse_instance_q7),
            "::",
            stringify!(numTaps)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_sparse_instance_q7>())).stateIndex as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_sparse_instance_q7),
            "::",
            stringify!(stateIndex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_sparse_instance_q7>())).pState as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_sparse_instance_q7),
            "::",
            stringify!(pState)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_sparse_instance_q7>())).pCoeffs as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_sparse_instance_q7),
            "::",
            stringify!(pCoeffs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_sparse_instance_q7>())).maxDelay as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_sparse_instance_q7),
            "::",
            stringify!(maxDelay)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<arm_fir_sparse_instance_q7>())).pTapDelay as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(arm_fir_sparse_instance_q7),
            "::",
            stringify!(pTapDelay)
        )
    );
}
extern "C" {
    #[doc = " @brief Processing function for the floating-point sparse FIR filter."]
    #[doc = " @param[in]  S           points to an instance of the floating-point sparse FIR structure."]
    #[doc = " @param[in]  pSrc        points to the block of input data."]
    #[doc = " @param[out] pDst        points to the block of output data"]
    #[doc = " @param[in]  pScratchIn  points to a temporary buffer of size blockSize."]
    #[doc = " @param[in]  blockSize   number of input samples to process per call."]
    pub fn arm_fir_sparse_f32(
        S: *mut arm_fir_sparse_instance_f32,
        pSrc: *const float32_t,
        pDst: *mut float32_t,
        pScratchIn: *mut float32_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief  Initialization function for the floating-point sparse FIR filter."]
    #[doc = " @param[in,out] S          points to an instance of the floating-point sparse FIR structure."]
    #[doc = " @param[in]     numTaps    number of nonzero coefficients in the filter."]
    #[doc = " @param[in]     pCoeffs    points to the array of filter coefficients."]
    #[doc = " @param[in]     pState     points to the state buffer."]
    #[doc = " @param[in]     pTapDelay  points to the array of offset times."]
    #[doc = " @param[in]     maxDelay   maximum offset time supported."]
    #[doc = " @param[in]     blockSize  number of samples that will be processed per block."]
    pub fn arm_fir_sparse_init_f32(
        S: *mut arm_fir_sparse_instance_f32,
        numTaps: u16,
        pCoeffs: *const float32_t,
        pState: *mut float32_t,
        pTapDelay: *mut i32,
        maxDelay: u16,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Processing function for the Q31 sparse FIR filter."]
    #[doc = " @param[in]  S           points to an instance of the Q31 sparse FIR structure."]
    #[doc = " @param[in]  pSrc        points to the block of input data."]
    #[doc = " @param[out] pDst        points to the block of output data"]
    #[doc = " @param[in]  pScratchIn  points to a temporary buffer of size blockSize."]
    #[doc = " @param[in]  blockSize   number of input samples to process per call."]
    pub fn arm_fir_sparse_q31(
        S: *mut arm_fir_sparse_instance_q31,
        pSrc: *const q31_t,
        pDst: *mut q31_t,
        pScratchIn: *mut q31_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief  Initialization function for the Q31 sparse FIR filter."]
    #[doc = " @param[in,out] S          points to an instance of the Q31 sparse FIR structure."]
    #[doc = " @param[in]     numTaps    number of nonzero coefficients in the filter."]
    #[doc = " @param[in]     pCoeffs    points to the array of filter coefficients."]
    #[doc = " @param[in]     pState     points to the state buffer."]
    #[doc = " @param[in]     pTapDelay  points to the array of offset times."]
    #[doc = " @param[in]     maxDelay   maximum offset time supported."]
    #[doc = " @param[in]     blockSize  number of samples that will be processed per block."]
    pub fn arm_fir_sparse_init_q31(
        S: *mut arm_fir_sparse_instance_q31,
        numTaps: u16,
        pCoeffs: *const q31_t,
        pState: *mut q31_t,
        pTapDelay: *mut i32,
        maxDelay: u16,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Processing function for the Q15 sparse FIR filter."]
    #[doc = " @param[in]  S            points to an instance of the Q15 sparse FIR structure."]
    #[doc = " @param[in]  pSrc         points to the block of input data."]
    #[doc = " @param[out] pDst         points to the block of output data"]
    #[doc = " @param[in]  pScratchIn   points to a temporary buffer of size blockSize."]
    #[doc = " @param[in]  pScratchOut  points to a temporary buffer of size blockSize."]
    #[doc = " @param[in]  blockSize    number of input samples to process per call."]
    pub fn arm_fir_sparse_q15(
        S: *mut arm_fir_sparse_instance_q15,
        pSrc: *const q15_t,
        pDst: *mut q15_t,
        pScratchIn: *mut q15_t,
        pScratchOut: *mut q31_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief  Initialization function for the Q15 sparse FIR filter."]
    #[doc = " @param[in,out] S          points to an instance of the Q15 sparse FIR structure."]
    #[doc = " @param[in]     numTaps    number of nonzero coefficients in the filter."]
    #[doc = " @param[in]     pCoeffs    points to the array of filter coefficients."]
    #[doc = " @param[in]     pState     points to the state buffer."]
    #[doc = " @param[in]     pTapDelay  points to the array of offset times."]
    #[doc = " @param[in]     maxDelay   maximum offset time supported."]
    #[doc = " @param[in]     blockSize  number of samples that will be processed per block."]
    pub fn arm_fir_sparse_init_q15(
        S: *mut arm_fir_sparse_instance_q15,
        numTaps: u16,
        pCoeffs: *const q15_t,
        pState: *mut q15_t,
        pTapDelay: *mut i32,
        maxDelay: u16,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief Processing function for the Q7 sparse FIR filter."]
    #[doc = " @param[in]  S            points to an instance of the Q7 sparse FIR structure."]
    #[doc = " @param[in]  pSrc         points to the block of input data."]
    #[doc = " @param[out] pDst         points to the block of output data"]
    #[doc = " @param[in]  pScratchIn   points to a temporary buffer of size blockSize."]
    #[doc = " @param[in]  pScratchOut  points to a temporary buffer of size blockSize."]
    #[doc = " @param[in]  blockSize    number of input samples to process per call."]
    pub fn arm_fir_sparse_q7(
        S: *mut arm_fir_sparse_instance_q7,
        pSrc: *const q7_t,
        pDst: *mut q7_t,
        pScratchIn: *mut q7_t,
        pScratchOut: *mut q31_t,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief  Initialization function for the Q7 sparse FIR filter."]
    #[doc = " @param[in,out] S          points to an instance of the Q7 sparse FIR structure."]
    #[doc = " @param[in]     numTaps    number of nonzero coefficients in the filter."]
    #[doc = " @param[in]     pCoeffs    points to the array of filter coefficients."]
    #[doc = " @param[in]     pState     points to the state buffer."]
    #[doc = " @param[in]     pTapDelay  points to the array of offset times."]
    #[doc = " @param[in]     maxDelay   maximum offset time supported."]
    #[doc = " @param[in]     blockSize  number of samples that will be processed per block."]
    pub fn arm_fir_sparse_init_q7(
        S: *mut arm_fir_sparse_instance_q7,
        numTaps: u16,
        pCoeffs: *const q7_t,
        pState: *mut q7_t,
        pTapDelay: *mut i32,
        maxDelay: u16,
        blockSize: u32,
    );
}
extern "C" {
    #[doc = " @brief  Floating-point sin_cos function."]
    #[doc = " @param[in]  theta   input value in degrees"]
    #[doc = " @param[out] pSinVal  points to the processed sine output."]
    #[doc = " @param[out] pCosVal  points to the processed cos output."]
    pub fn arm_sin_cos_f32(theta: float32_t, pSinVal: *mut float32_t, pCosVal: *mut float32_t);
}
extern "C" {
    #[doc = " @brief  Q31 sin_cos function."]
    #[doc = " @param[in]  theta    scaled input value in degrees"]
    #[doc = " @param[out] pSinVal  points to the processed sine output."]
    #[doc = " @param[out] pCosVal  points to the processed cosine output."]
    pub fn arm_sin_cos_q31(theta: q31_t, pSinVal: *mut q31_t, pCosVal: *mut q31_t);
}
extern "C" {
    #[doc = " @brief  Floating-point complex conjugate."]
    #[doc = " @param[in]  pSrc        points to the input vector"]
    #[doc = " @param[out] pDst        points to the output vector"]
    #[doc = " @param[in]  numSamples  number of complex samples in each vector"]
    pub fn arm_cmplx_conj_f32(pSrc: *const float32_t, pDst: *mut float32_t, numSamples: u32);
}
extern "C" {
    #[doc = " @brief  Q31 complex conjugate."]
    #[doc = " @param[in]  pSrc        points to the input vector"]
    #[doc = " @param[out] pDst        points to the output vector"]
    #[doc = " @param[in]  numSamples  number of complex samples in each vector"]
    pub fn arm_cmplx_conj_q31(pSrc: *const q31_t, pDst: *mut q31_t, numSamples: u32);
}
extern "C" {
    #[doc = " @brief  Q15 complex conjugate."]
    #[doc = " @param[in]  pSrc        points to the input vector"]
    #[doc = " @param[out] pDst        points to the output vector"]
    #[doc = " @param[in]  numSamples  number of complex samples in each vector"]
    pub fn arm_cmplx_conj_q15(pSrc: *const q15_t, pDst: *mut q15_t, numSamples: u32);
}
extern "C" {
    #[doc = " @brief  Floating-point complex magnitude squared"]
    #[doc = " @param[in]  pSrc        points to the complex input vector"]
    #[doc = " @param[out] pDst        points to the real output vector"]
    #[doc = " @param[in]  numSamples  number of complex samples in the input vector"]
    pub fn arm_cmplx_mag_squared_f32(pSrc: *const float32_t, pDst: *mut float32_t, numSamples: u32);
}
extern "C" {
    #[doc = " @brief  Q31 complex magnitude squared"]
    #[doc = " @param[in]  pSrc        points to the complex input vector"]
    #[doc = " @param[out] pDst        points to the real output vector"]
    #[doc = " @param[in]  numSamples  number of complex samples in the input vector"]
    pub fn arm_cmplx_mag_squared_q31(pSrc: *const q31_t, pDst: *mut q31_t, numSamples: u32);
}
extern "C" {
    #[doc = " @brief  Q15 complex magnitude squared"]
    #[doc = " @param[in]  pSrc        points to the complex input vector"]
    #[doc = " @param[out] pDst        points to the real output vector"]
    #[doc = " @param[in]  numSamples  number of complex samples in the input vector"]
    pub fn arm_cmplx_mag_squared_q15(pSrc: *const q15_t, pDst: *mut q15_t, numSamples: u32);
}
extern "C" {
    #[doc = " @brief Floating-point matrix inverse."]
    #[doc = " @param[in]  src   points to the instance of the input floating-point matrix structure."]
    #[doc = " @param[out] dst   points to the instance of the output floating-point matrix structure."]
    #[doc = " @return The function returns ARM_MATH_SIZE_MISMATCH, if the dimensions do not match."]
    #[doc = " If the input matrix is singular (does not have an inverse), then the algorithm terminates and returns error status ARM_MATH_SINGULAR."]
    pub fn arm_mat_inverse_f32(
        src: *const arm_matrix_instance_f32,
        dst: *mut arm_matrix_instance_f32,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief Floating-point matrix inverse."]
    #[doc = " @param[in]  src   points to the instance of the input floating-point matrix structure."]
    #[doc = " @param[out] dst   points to the instance of the output floating-point matrix structure."]
    #[doc = " @return The function returns ARM_MATH_SIZE_MISMATCH, if the dimensions do not match."]
    #[doc = " If the input matrix is singular (does not have an inverse), then the algorithm terminates and returns error status ARM_MATH_SINGULAR."]
    pub fn arm_mat_inverse_f64(
        src: *const arm_matrix_instance_f64,
        dst: *mut arm_matrix_instance_f64,
    ) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief  Fast approximation to the trigonometric sine function for floating-point data."]
    #[doc = " @param[in] x  input value in radians."]
    #[doc = " @return  sin(x)."]
    pub fn arm_sin_f32(x: float32_t) -> float32_t;
}
extern "C" {
    #[doc = " @brief  Fast approximation to the trigonometric sine function for Q31 data."]
    #[doc = " @param[in] x  Scaled input value in radians."]
    #[doc = " @return  sin(x)."]
    pub fn arm_sin_q31(x: q31_t) -> q31_t;
}
extern "C" {
    #[doc = " @brief  Fast approximation to the trigonometric sine function for Q15 data."]
    #[doc = " @param[in] x  Scaled input value in radians."]
    #[doc = " @return  sin(x)."]
    pub fn arm_sin_q15(x: q15_t) -> q15_t;
}
extern "C" {
    #[doc = " @brief  Fast approximation to the trigonometric cosine function for floating-point data."]
    #[doc = " @param[in] x  input value in radians."]
    #[doc = " @return  cos(x)."]
    pub fn arm_cos_f32(x: float32_t) -> float32_t;
}
extern "C" {
    #[doc = " @brief Fast approximation to the trigonometric cosine function for Q31 data."]
    #[doc = " @param[in] x  Scaled input value in radians."]
    #[doc = " @return  cos(x)."]
    pub fn arm_cos_q31(x: q31_t) -> q31_t;
}
extern "C" {
    #[doc = " @brief  Fast approximation to the trigonometric cosine function for Q15 data."]
    #[doc = " @param[in] x  Scaled input value in radians."]
    #[doc = " @return  cos(x)."]
    pub fn arm_cos_q15(x: q15_t) -> q15_t;
}
extern "C" {
    #[doc = "@brief         Q31 square root function."]
    #[doc = "@param[in]     in    input value.  The range of the input value is [0 +1) or 0x00000000 to 0x7FFFFFFF"]
    #[doc = "@param[out]    pOut  points to square root of input value"]
    #[doc = "@return        execution status"]
    #[doc = "- \\ref ARM_MATH_SUCCESS        : input value is positive"]
    #[doc = "- \\ref ARM_MATH_ARGUMENT_ERROR : input value is negative; *pOut is set to 0"]
    pub fn arm_sqrt_q31(in_: q31_t, pOut: *mut q31_t) -> arm_status::Type;
}
extern "C" {
    #[doc = "@brief         Q15 square root function."]
    #[doc = "@param[in]     in    input value.  The range of the input value is [0 +1) or 0x0000 to 0x7FFF"]
    #[doc = "@param[out]    pOut  points to square root of input value"]
    #[doc = "@return        execution status"]
    #[doc = "- \\ref ARM_MATH_SUCCESS        : input value is positive"]
    #[doc = "- \\ref ARM_MATH_ARGUMENT_ERROR : input value is negative; *pOut is set to 0"]
    pub fn arm_sqrt_q15(in_: q15_t, pOut: *mut q15_t) -> arm_status::Type;
}
extern "C" {
    #[doc = " @brief  Vector Floating-point square root function."]
    #[doc = " @param[in]  pIn   input vector."]
    #[doc = " @param[out] pOut  vector of square roots of input elements."]
    #[doc = " @param[in]  len   length of input vector."]
    #[doc = " @return The function returns ARM_MATH_SUCCESS if input value is positive value or ARM_MATH_ARGUMENT_ERROR if"]
    #[doc = " <code>in</code> is negative value and returns zero output for negative values."]
    pub fn arm_vsqrt_f32(pIn: *mut float32_t, pOut: *mut float32_t, len: u16);
}
extern "C" {
    pub fn arm_vsqrt_q31(pIn: *mut q31_t, pOut: *mut q31_t, len: u16);
}
extern "C" {
    pub fn arm_vsqrt_q15(pIn: *mut q15_t, pOut: *mut q15_t, len: u16);
}
extern "C" {
    #[doc = " @brief  Sum of the squares of the elements of a Q31 vector."]
    #[doc = " @param[in]  pSrc       is input pointer"]
    #[doc = " @param[in]  blockSize  is the number of samples to process"]
    #[doc = " @param[out] pResult    is output value."]
    pub fn arm_power_q31(pSrc: *const q31_t, blockSize: u32, pResult: *mut q63_t);
}
extern "C" {
    #[doc = " @brief  Sum of the squares of the elements of a floating-point vector."]
    #[doc = " @param[in]  pSrc       is input pointer"]
    #[doc = " @param[in]  blockSize  is the number of samples to process"]
    #[doc = " @param[out] pResult    is output value."]
    pub fn arm_power_f32(pSrc: *const float32_t, blockSize: u32, pResult: *mut float32_t);
}
extern "C" {
    #[doc = " @brief  Sum of the squares of the elements of a Q15 vector."]
    #[doc = " @param[in]  pSrc       is input pointer"]
    #[doc = " @param[in]  blockSize  is the number of samples to process"]
    #[doc = " @param[out] pResult    is output value."]
    pub fn arm_power_q15(pSrc: *const q15_t, blockSize: u32, pResult: *mut q63_t);
}
extern "C" {
    #[doc = " @brief  Sum of the squares of the elements of a Q7 vector."]
    #[doc = " @param[in]  pSrc       is input pointer"]
    #[doc = " @param[in]  blockSize  is the number of samples to process"]
    #[doc = " @param[out] pResult    is output value."]
    pub fn arm_power_q7(pSrc: *const q7_t, blockSize: u32, pResult: *mut q31_t);
}
extern "C" {
    #[doc = " @brief  Mean value of a Q7 vector."]
    #[doc = " @param[in]  pSrc       is input pointer"]
    #[doc = " @param[in]  blockSize  is the number of samples to process"]
    #[doc = " @param[out] pResult    is output value."]
    pub fn arm_mean_q7(pSrc: *const q7_t, blockSize: u32, pResult: *mut q7_t);
}
extern "C" {
    #[doc = " @brief  Mean value of a Q15 vector."]
    #[doc = " @param[in]  pSrc       is input pointer"]
    #[doc = " @param[in]  blockSize  is the number of samples to process"]
    #[doc = " @param[out] pResult    is output value."]
    pub fn arm_mean_q15(pSrc: *const q15_t, blockSize: u32, pResult: *mut q15_t);
}
extern "C" {
    #[doc = " @brief  Mean value of a Q31 vector."]
    #[doc = " @param[in]  pSrc       is input pointer"]
    #[doc = " @param[in]  blockSize  is the number of samples to process"]
    #[doc = " @param[out] pResult    is output value."]
    pub fn arm_mean_q31(pSrc: *const q31_t, blockSize: u32, pResult: *mut q31_t);
}
extern "C" {
    #[doc = " @brief  Mean value of a floating-point vector."]
    #[doc = " @param[in]  pSrc       is input pointer"]
    #[doc = " @param[in]  blockSize  is the number of samples to process"]
    #[doc = " @param[out] pResult    is output value."]
    pub fn arm_mean_f32(pSrc: *const float32_t, blockSize: u32, pResult: *mut float32_t);
}
extern "C" {
    #[doc = " @brief  Variance of the elements of a floating-point vector."]
    #[doc = " @param[in]  pSrc       is input pointer"]
    #[doc = " @param[in]  blockSize  is the number of samples to process"]
    #[doc = " @param[out] pResult    is output value."]
    pub fn arm_var_f32(pSrc: *const float32_t, blockSize: u32, pResult: *mut float32_t);
}
extern "C" {
    #[doc = " @brief  Variance of the elements of a Q31 vector."]
    #[doc = " @param[in]  pSrc       is input pointer"]
    #[doc = " @param[in]  blockSize  is the number of samples to process"]
    #[doc = " @param[out] pResult    is output value."]
    pub fn arm_var_q31(pSrc: *const q31_t, blockSize: u32, pResult: *mut q31_t);
}
extern "C" {
    #[doc = " @brief  Variance of the elements of a Q15 vector."]
    #[doc = " @param[in]  pSrc       is input pointer"]
    #[doc = " @param[in]  blockSize  is the number of samples to process"]
    #[doc = " @param[out] pResult    is output value."]
    pub fn arm_var_q15(pSrc: *const q15_t, blockSize: u32, pResult: *mut q15_t);
}
extern "C" {
    #[doc = " @brief  Root Mean Square of the elements of a floating-point vector."]
    #[doc = " @param[in]  pSrc       is input pointer"]
    #[doc = " @param[in]  blockSize  is the number of samples to process"]
    #[doc = " @param[out] pResult    is output value."]
    pub fn arm_rms_f32(pSrc: *const float32_t, blockSize: u32, pResult: *mut float32_t);
}
extern "C" {
    #[doc = " @brief  Root Mean Square of the elements of a Q31 vector."]
    #[doc = " @param[in]  pSrc       is input pointer"]
    #[doc = " @param[in]  blockSize  is the number of samples to process"]
    #[doc = " @param[out] pResult    is output value."]
    pub fn arm_rms_q31(pSrc: *const q31_t, blockSize: u32, pResult: *mut q31_t);
}
extern "C" {
    #[doc = " @brief  Root Mean Square of the elements of a Q15 vector."]
    #[doc = " @param[in]  pSrc       is input pointer"]
    #[doc = " @param[in]  blockSize  is the number of samples to process"]
    #[doc = " @param[out] pResult    is output value."]
    pub fn arm_rms_q15(pSrc: *const q15_t, blockSize: u32, pResult: *mut q15_t);
}
extern "C" {
    #[doc = " @brief  Standard deviation of the elements of a floating-point vector."]
    #[doc = " @param[in]  pSrc       is input pointer"]
    #[doc = " @param[in]  blockSize  is the number of samples to process"]
    #[doc = " @param[out] pResult    is output value."]
    pub fn arm_std_f32(pSrc: *const float32_t, blockSize: u32, pResult: *mut float32_t);
}
extern "C" {
    #[doc = " @brief  Standard deviation of the elements of a Q31 vector."]
    #[doc = " @param[in]  pSrc       is input pointer"]
    #[doc = " @param[in]  blockSize  is the number of samples to process"]
    #[doc = " @param[out] pResult    is output value."]
    pub fn arm_std_q31(pSrc: *const q31_t, blockSize: u32, pResult: *mut q31_t);
}
extern "C" {
    #[doc = " @brief  Standard deviation of the elements of a Q15 vector."]
    #[doc = " @param[in]  pSrc       is input pointer"]
    #[doc = " @param[in]  blockSize  is the number of samples to process"]
    #[doc = " @param[out] pResult    is output value."]
    pub fn arm_std_q15(pSrc: *const q15_t, blockSize: u32, pResult: *mut q15_t);
}
extern "C" {
    #[doc = " @brief  Floating-point complex magnitude"]
    #[doc = " @param[in]  pSrc        points to the complex input vector"]
    #[doc = " @param[out] pDst        points to the real output vector"]
    #[doc = " @param[in]  numSamples  number of complex samples in the input vector"]
    pub fn arm_cmplx_mag_f32(pSrc: *const float32_t, pDst: *mut float32_t, numSamples: u32);
}
extern "C" {
    #[doc = " @brief  Q31 complex magnitude"]
    #[doc = " @param[in]  pSrc        points to the complex input vector"]
    #[doc = " @param[out] pDst        points to the real output vector"]
    #[doc = " @param[in]  numSamples  number of complex samples in the input vector"]
    pub fn arm_cmplx_mag_q31(pSrc: *const q31_t, pDst: *mut q31_t, numSamples: u32);
}
extern "C" {
    #[doc = " @brief  Q15 complex magnitude"]
    #[doc = " @param[in]  pSrc        points to the complex input vector"]
    #[doc = " @param[out] pDst        points to the real output vector"]
    #[doc = " @param[in]  numSamples  number of complex samples in the input vector"]
    pub fn arm_cmplx_mag_q15(pSrc: *const q15_t, pDst: *mut q15_t, numSamples: u32);
}
extern "C" {
    #[doc = " @brief  Q15 complex dot product"]
    #[doc = " @param[in]  pSrcA       points to the first input vector"]
    #[doc = " @param[in]  pSrcB       points to the second input vector"]
    #[doc = " @param[in]  numSamples  number of complex samples in each vector"]
    #[doc = " @param[out] realResult  real part of the result returned here"]
    #[doc = " @param[out] imagResult  imaginary part of the result returned here"]
    pub fn arm_cmplx_dot_prod_q15(
        pSrcA: *const q15_t,
        pSrcB: *const q15_t,
        numSamples: u32,
        realResult: *mut q31_t,
        imagResult: *mut q31_t,
    );
}
extern "C" {
    #[doc = " @brief  Q31 complex dot product"]
    #[doc = " @param[in]  pSrcA       points to the first input vector"]
    #[doc = " @param[in]  pSrcB       points to the second input vector"]
    #[doc = " @param[in]  numSamples  number of complex samples in each vector"]
    #[doc = " @param[out] realResult  real part of the result returned here"]
    #[doc = " @param[out] imagResult  imaginary part of the result returned here"]
    pub fn arm_cmplx_dot_prod_q31(
        pSrcA: *const q31_t,
        pSrcB: *const q31_t,
        numSamples: u32,
        realResult: *mut q63_t,
        imagResult: *mut q63_t,
    );
}
extern "C" {
    #[doc = " @brief  Floating-point complex dot product"]
    #[doc = " @param[in]  pSrcA       points to the first input vector"]
    #[doc = " @param[in]  pSrcB       points to the second input vector"]
    #[doc = " @param[in]  numSamples  number of complex samples in each vector"]
    #[doc = " @param[out] realResult  real part of the result returned here"]
    #[doc = " @param[out] imagResult  imaginary part of the result returned here"]
    pub fn arm_cmplx_dot_prod_f32(
        pSrcA: *const float32_t,
        pSrcB: *const float32_t,
        numSamples: u32,
        realResult: *mut float32_t,
        imagResult: *mut float32_t,
    );
}
extern "C" {
    #[doc = " @brief  Q15 complex-by-real multiplication"]
    #[doc = " @param[in]  pSrcCmplx   points to the complex input vector"]
    #[doc = " @param[in]  pSrcReal    points to the real input vector"]
    #[doc = " @param[out] pCmplxDst   points to the complex output vector"]
    #[doc = " @param[in]  numSamples  number of samples in each vector"]
    pub fn arm_cmplx_mult_real_q15(
        pSrcCmplx: *const q15_t,
        pSrcReal: *const q15_t,
        pCmplxDst: *mut q15_t,
        numSamples: u32,
    );
}
extern "C" {
    #[doc = " @brief  Q31 complex-by-real multiplication"]
    #[doc = " @param[in]  pSrcCmplx   points to the complex input vector"]
    #[doc = " @param[in]  pSrcReal    points to the real input vector"]
    #[doc = " @param[out] pCmplxDst   points to the complex output vector"]
    #[doc = " @param[in]  numSamples  number of samples in each vector"]
    pub fn arm_cmplx_mult_real_q31(
        pSrcCmplx: *const q31_t,
        pSrcReal: *const q31_t,
        pCmplxDst: *mut q31_t,
        numSamples: u32,
    );
}
extern "C" {
    #[doc = " @brief  Floating-point complex-by-real multiplication"]
    #[doc = " @param[in]  pSrcCmplx   points to the complex input vector"]
    #[doc = " @param[in]  pSrcReal    points to the real input vector"]
    #[doc = " @param[out] pCmplxDst   points to the complex output vector"]
    #[doc = " @param[in]  numSamples  number of samples in each vector"]
    pub fn arm_cmplx_mult_real_f32(
        pSrcCmplx: *const float32_t,
        pSrcReal: *const float32_t,
        pCmplxDst: *mut float32_t,
        numSamples: u32,
    );
}
extern "C" {
    #[doc = " @brief  Minimum value of a Q7 vector."]
    #[doc = " @param[in]  pSrc       is input pointer"]
    #[doc = " @param[in]  blockSize  is the number of samples to process"]
    #[doc = " @param[out] result     is output pointer"]
    #[doc = " @param[in]  index      is the array index of the minimum value in the input buffer."]
    pub fn arm_min_q7(pSrc: *const q7_t, blockSize: u32, result: *mut q7_t, index: *mut u32);
}
extern "C" {
    #[doc = " @brief  Minimum value of a Q15 vector."]
    #[doc = " @param[in]  pSrc       is input pointer"]
    #[doc = " @param[in]  blockSize  is the number of samples to process"]
    #[doc = " @param[out] pResult    is output pointer"]
    #[doc = " @param[in]  pIndex     is the array index of the minimum value in the input buffer."]
    pub fn arm_min_q15(pSrc: *const q15_t, blockSize: u32, pResult: *mut q15_t, pIndex: *mut u32);
}
extern "C" {
    #[doc = " @brief  Minimum value of a Q31 vector."]
    #[doc = " @param[in]  pSrc       is input pointer"]
    #[doc = " @param[in]  blockSize  is the number of samples to process"]
    #[doc = " @param[out] pResult    is output pointer"]
    #[doc = " @param[out] pIndex     is the array index of the minimum value in the input buffer."]
    pub fn arm_min_q31(pSrc: *const q31_t, blockSize: u32, pResult: *mut q31_t, pIndex: *mut u32);
}
extern "C" {
    #[doc = " @brief  Minimum value of a floating-point vector."]
    #[doc = " @param[in]  pSrc       is input pointer"]
    #[doc = " @param[in]  blockSize  is the number of samples to process"]
    #[doc = " @param[out] pResult    is output pointer"]
    #[doc = " @param[out] pIndex     is the array index of the minimum value in the input buffer."]
    pub fn arm_min_f32(
        pSrc: *const float32_t,
        blockSize: u32,
        pResult: *mut float32_t,
        pIndex: *mut u32,
    );
}
extern "C" {
    #[doc = " @brief Maximum value of a Q7 vector."]
    #[doc = " @param[in]  pSrc       points to the input buffer"]
    #[doc = " @param[in]  blockSize  length of the input vector"]
    #[doc = " @param[out] pResult    maximum value returned here"]
    #[doc = " @param[out] pIndex     index of maximum value returned here"]
    pub fn arm_max_q7(pSrc: *const q7_t, blockSize: u32, pResult: *mut q7_t, pIndex: *mut u32);
}
extern "C" {
    #[doc = " @brief Maximum value of a Q15 vector."]
    #[doc = " @param[in]  pSrc       points to the input buffer"]
    #[doc = " @param[in]  blockSize  length of the input vector"]
    #[doc = " @param[out] pResult    maximum value returned here"]
    #[doc = " @param[out] pIndex     index of maximum value returned here"]
    pub fn arm_max_q15(pSrc: *const q15_t, blockSize: u32, pResult: *mut q15_t, pIndex: *mut u32);
}
extern "C" {
    #[doc = " @brief Maximum value of a Q31 vector."]
    #[doc = " @param[in]  pSrc       points to the input buffer"]
    #[doc = " @param[in]  blockSize  length of the input vector"]
    #[doc = " @param[out] pResult    maximum value returned here"]
    #[doc = " @param[out] pIndex     index of maximum value returned here"]
    pub fn arm_max_q31(pSrc: *const q31_t, blockSize: u32, pResult: *mut q31_t, pIndex: *mut u32);
}
extern "C" {
    #[doc = " @brief Maximum value of a floating-point vector."]
    #[doc = " @param[in]  pSrc       points to the input buffer"]
    #[doc = " @param[in]  blockSize  length of the input vector"]
    #[doc = " @param[out] pResult    maximum value returned here"]
    #[doc = " @param[out] pIndex     index of maximum value returned here"]
    pub fn arm_max_f32(
        pSrc: *const float32_t,
        blockSize: u32,
        pResult: *mut float32_t,
        pIndex: *mut u32,
    );
}
extern "C" {
    #[doc = " @brief  Q15 complex-by-complex multiplication"]
    #[doc = " @param[in]  pSrcA       points to the first input vector"]
    #[doc = " @param[in]  pSrcB       points to the second input vector"]
    #[doc = " @param[out] pDst        points to the output vector"]
    #[doc = " @param[in]  numSamples  number of complex samples in each vector"]
    pub fn arm_cmplx_mult_cmplx_q15(
        pSrcA: *const q15_t,
        pSrcB: *const q15_t,
        pDst: *mut q15_t,
        numSamples: u32,
    );
}
extern "C" {
    #[doc = " @brief  Q31 complex-by-complex multiplication"]
    #[doc = " @param[in]  pSrcA       points to the first input vector"]
    #[doc = " @param[in]  pSrcB       points to the second input vector"]
    #[doc = " @param[out] pDst        points to the output vector"]
    #[doc = " @param[in]  numSamples  number of complex samples in each vector"]
    pub fn arm_cmplx_mult_cmplx_q31(
        pSrcA: *const q31_t,
        pSrcB: *const q31_t,
        pDst: *mut q31_t,
        numSamples: u32,
    );
}
extern "C" {
    #[doc = " @brief  Floating-point complex-by-complex multiplication"]
    #[doc = " @param[in]  pSrcA       points to the first input vector"]
    #[doc = " @param[in]  pSrcB       points to the second input vector"]
    #[doc = " @param[out] pDst        points to the output vector"]
    #[doc = " @param[in]  numSamples  number of complex samples in each vector"]
    pub fn arm_cmplx_mult_cmplx_f32(
        pSrcA: *const float32_t,
        pSrcB: *const float32_t,
        pDst: *mut float32_t,
        numSamples: u32,
    );
}
extern "C" {
    #[doc = " @brief Converts the elements of the floating-point vector to Q31 vector."]
    #[doc = " @param[in]  pSrc       points to the floating-point input vector"]
    #[doc = " @param[out] pDst       points to the Q31 output vector"]
    #[doc = " @param[in]  blockSize  length of the input vector"]
    pub fn arm_float_to_q31(pSrc: *const float32_t, pDst: *mut q31_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief Converts the elements of the floating-point vector to Q15 vector."]
    #[doc = " @param[in]  pSrc       points to the floating-point input vector"]
    #[doc = " @param[out] pDst       points to the Q15 output vector"]
    #[doc = " @param[in]  blockSize  length of the input vector"]
    pub fn arm_float_to_q15(pSrc: *const float32_t, pDst: *mut q15_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief Converts the elements of the floating-point vector to Q7 vector."]
    #[doc = " @param[in]  pSrc       points to the floating-point input vector"]
    #[doc = " @param[out] pDst       points to the Q7 output vector"]
    #[doc = " @param[in]  blockSize  length of the input vector"]
    pub fn arm_float_to_q7(pSrc: *const float32_t, pDst: *mut q7_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  Converts the elements of the Q31 vector to floating-point vector."]
    #[doc = " @param[in]  pSrc       is input pointer"]
    #[doc = " @param[out] pDst       is output pointer"]
    #[doc = " @param[in]  blockSize  is the number of samples to process"]
    pub fn arm_q31_to_float(pSrc: *const q31_t, pDst: *mut float32_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  Converts the elements of the Q31 vector to Q15 vector."]
    #[doc = " @param[in]  pSrc       is input pointer"]
    #[doc = " @param[out] pDst       is output pointer"]
    #[doc = " @param[in]  blockSize  is the number of samples to process"]
    pub fn arm_q31_to_q15(pSrc: *const q31_t, pDst: *mut q15_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  Converts the elements of the Q31 vector to Q7 vector."]
    #[doc = " @param[in]  pSrc       is input pointer"]
    #[doc = " @param[out] pDst       is output pointer"]
    #[doc = " @param[in]  blockSize  is the number of samples to process"]
    pub fn arm_q31_to_q7(pSrc: *const q31_t, pDst: *mut q7_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  Converts the elements of the Q15 vector to floating-point vector."]
    #[doc = " @param[in]  pSrc       is input pointer"]
    #[doc = " @param[out] pDst       is output pointer"]
    #[doc = " @param[in]  blockSize  is the number of samples to process"]
    pub fn arm_q15_to_float(pSrc: *const q15_t, pDst: *mut float32_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  Converts the elements of the Q15 vector to Q31 vector."]
    #[doc = " @param[in]  pSrc       is input pointer"]
    #[doc = " @param[out] pDst       is output pointer"]
    #[doc = " @param[in]  blockSize  is the number of samples to process"]
    pub fn arm_q15_to_q31(pSrc: *const q15_t, pDst: *mut q31_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  Converts the elements of the Q15 vector to Q7 vector."]
    #[doc = " @param[in]  pSrc       is input pointer"]
    #[doc = " @param[out] pDst       is output pointer"]
    #[doc = " @param[in]  blockSize  is the number of samples to process"]
    pub fn arm_q15_to_q7(pSrc: *const q15_t, pDst: *mut q7_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  Converts the elements of the Q7 vector to floating-point vector."]
    #[doc = " @param[in]  pSrc       is input pointer"]
    #[doc = " @param[out] pDst       is output pointer"]
    #[doc = " @param[in]  blockSize  is the number of samples to process"]
    pub fn arm_q7_to_float(pSrc: *const q7_t, pDst: *mut float32_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  Converts the elements of the Q7 vector to Q31 vector."]
    #[doc = " @param[in]  pSrc       input pointer"]
    #[doc = " @param[out] pDst       output pointer"]
    #[doc = " @param[in]  blockSize  number of samples to process"]
    pub fn arm_q7_to_q31(pSrc: *const q7_t, pDst: *mut q31_t, blockSize: u32);
}
extern "C" {
    #[doc = " @brief  Converts the elements of the Q7 vector to Q15 vector."]
    #[doc = " @param[in]  pSrc       input pointer"]
    #[doc = " @param[out] pDst       output pointer"]
    #[doc = " @param[in]  blockSize  number of samples to process"]
    pub fn arm_q7_to_q15(pSrc: *const q7_t, pDst: *mut q15_t, blockSize: u32);
}
extern "C" {
    pub static armBitRevTable: [u16; 1024usize];
}
extern "C" {
    pub static armBitRevIndexTable16: [u16; 20usize];
}
extern "C" {
    pub static armBitRevIndexTable32: [u16; 48usize];
}
extern "C" {
    pub static armBitRevIndexTable64: [u16; 56usize];
}
extern "C" {
    pub static armBitRevIndexTable128: [u16; 208usize];
}
extern "C" {
    pub static armBitRevIndexTable256: [u16; 440usize];
}
extern "C" {
    pub static armBitRevIndexTable512: [u16; 448usize];
}
extern "C" {
    pub static armBitRevIndexTable1024: [u16; 1800usize];
}
extern "C" {
    pub static armBitRevIndexTable2048: [u16; 3808usize];
}
extern "C" {
    pub static armBitRevIndexTable4096: [u16; 4032usize];
}
extern "C" {
    pub static armBitRevIndexTable_fixed_16: [u16; 12usize];
}
extern "C" {
    pub static armBitRevIndexTable_fixed_32: [u16; 24usize];
}
extern "C" {
    pub static armBitRevIndexTable_fixed_64: [u16; 56usize];
}
extern "C" {
    pub static armBitRevIndexTable_fixed_128: [u16; 112usize];
}
extern "C" {
    pub static armBitRevIndexTable_fixed_256: [u16; 240usize];
}
extern "C" {
    pub static armBitRevIndexTable_fixed_512: [u16; 480usize];
}
extern "C" {
    pub static armBitRevIndexTable_fixed_1024: [u16; 992usize];
}
extern "C" {
    pub static armBitRevIndexTable_fixed_2048: [u16; 1984usize];
}
extern "C" {
    pub static armBitRevIndexTable_fixed_4096: [u16; 4032usize];
}
extern "C" {
    pub static armRecipTableQ15: [q15_t; 64usize];
}
extern "C" {
    pub static armRecipTableQ31: [q31_t; 64usize];
}
extern "C" {
    pub static arm_cfft_sR_f32_len16: arm_cfft_instance_f32;
}
extern "C" {
    pub static arm_cfft_sR_f32_len32: arm_cfft_instance_f32;
}
extern "C" {
    pub static arm_cfft_sR_f32_len64: arm_cfft_instance_f32;
}
extern "C" {
    pub static arm_cfft_sR_f32_len128: arm_cfft_instance_f32;
}
extern "C" {
    pub static arm_cfft_sR_f32_len256: arm_cfft_instance_f32;
}
extern "C" {
    pub static arm_cfft_sR_f32_len512: arm_cfft_instance_f32;
}
extern "C" {
    pub static arm_cfft_sR_f32_len1024: arm_cfft_instance_f32;
}
extern "C" {
    pub static arm_cfft_sR_f32_len2048: arm_cfft_instance_f32;
}
extern "C" {
    pub static arm_cfft_sR_f32_len4096: arm_cfft_instance_f32;
}
extern "C" {
    pub static arm_cfft_sR_q31_len16: arm_cfft_instance_q31;
}
extern "C" {
    pub static arm_cfft_sR_q31_len32: arm_cfft_instance_q31;
}
extern "C" {
    pub static arm_cfft_sR_q31_len64: arm_cfft_instance_q31;
}
extern "C" {
    pub static arm_cfft_sR_q31_len128: arm_cfft_instance_q31;
}
extern "C" {
    pub static arm_cfft_sR_q31_len256: arm_cfft_instance_q31;
}
extern "C" {
    pub static arm_cfft_sR_q31_len512: arm_cfft_instance_q31;
}
extern "C" {
    pub static arm_cfft_sR_q31_len1024: arm_cfft_instance_q31;
}
extern "C" {
    pub static arm_cfft_sR_q31_len2048: arm_cfft_instance_q31;
}
extern "C" {
    pub static arm_cfft_sR_q31_len4096: arm_cfft_instance_q31;
}
extern "C" {
    pub static arm_cfft_sR_q15_len16: arm_cfft_instance_q15;
}
extern "C" {
    pub static arm_cfft_sR_q15_len32: arm_cfft_instance_q15;
}
extern "C" {
    pub static arm_cfft_sR_q15_len64: arm_cfft_instance_q15;
}
extern "C" {
    pub static arm_cfft_sR_q15_len128: arm_cfft_instance_q15;
}
extern "C" {
    pub static arm_cfft_sR_q15_len256: arm_cfft_instance_q15;
}
extern "C" {
    pub static arm_cfft_sR_q15_len512: arm_cfft_instance_q15;
}
extern "C" {
    pub static arm_cfft_sR_q15_len1024: arm_cfft_instance_q15;
}
extern "C" {
    pub static arm_cfft_sR_q15_len2048: arm_cfft_instance_q15;
}
extern "C" {
    pub static arm_cfft_sR_q15_len4096: arm_cfft_instance_q15;
}
